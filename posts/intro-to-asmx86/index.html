<!doctype html><html lang=en><head><title>Introduction to asm :: h4x5p4c3's blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="What is assembly language ? A processor understands only machine language instructions which are strings of 1&amp;rsquo;s and 0&amp;rsquo;s. Assembly language is basically just a wrapper on top of machine code. However machine language is too obscure and complex to understand so low level assembly language is designed for specific family of processors.
Each family of processors have its own set of instructions for handling various operations. These set of instructions are called machine-language-instructions."><meta name=keywords content=","><meta name=robots content="noodp"><link rel=canonical href=/posts/intro-to-asmx86/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/green.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/img/favicon/green.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="h4x5p4c3"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Introduction to asm"><meta property="og:description" content="What is assembly language ? A processor understands only machine language instructions which are strings of 1&amp;rsquo;s and 0&amp;rsquo;s. Assembly language is basically just a wrapper on top of machine code. However machine language is too obscure and complex to understand so low level assembly language is designed for specific family of processors.
Each family of processors have its own set of instructions for handling various operations. These set of instructions are called machine-language-instructions."><meta property="og:url" content="/posts/intro-to-asmx86/"><meta property="og:site_name" content="h4x5p4c3's blog"><meta property="og:image" content="/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-08-13 00:00:00 +0000 UTC"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>h4x5p4c3's blog</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about/>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about/>About</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/intro-to-asmx86/>Introduction to asm</a></h1><div class=post-meta><span class=post-date>2020-08-13</span>
<span class=post-author>:: jones</span></div><span class=post-tags>#<a href=/tags/x86/>x86</a>&nbsp;
#<a href=/tags/asm/>asm</a>&nbsp;</span><div class=post-content><div><h2 id=what-is-assembly-language->What is assembly language ?<a href=#what-is-assembly-language- class=hanchor arialabel=Anchor>&#8983;</a></h2><p>A processor understands only machine language instructions which are strings of 1&rsquo;s and 0&rsquo;s. Assembly language is
basically just a wrapper on top of machine code. However machine language is too obscure and complex to understand so low level assembly language is designed for specific family of processors.</p><p>Each family of processors have its own set of instructions for handling various operations. These set of instructions are
called machine-language-instructions.</p><h2 id=x86-registers>x86 Registers!<a href=#x86-registers class=hanchor arialabel=Anchor>&#8983;</a></h2><pre><code>x86 processors have 8, 32-bit general purpose registers
</code></pre><p>EAX is called as the accumulator since it does number of arithmetic operations. In division and multiplication,
one of the numbers must be in AX(32-bit) or AL(16-bit)</p><pre><code>AX - primary accumulator  =&gt; AH, AL
</code></pre><p>EBX is called as the base index (eg:arrays) holds the address of the base storage location from where
the data is stored continuously. Base register value is used to find the data that is required.</p><pre><code>BX - base register  =&gt; BH, BL
</code></pre><p>ECX is known as the counter as it&rsquo;s used to hold a loop index. While shifting and rotating bits CX is used as counter.</p><pre><code>CX - counter register =&gt; CH, CL
</code></pre><p>EDX is the data register is used in I/O operations as well as preferred in division and multiplication
while execution of large values.(DX and DL)</p><pre><code>DX - data register  =&gt; DH, DL
</code></pre><p>ESI - used for string operations as source index</p><pre><code>SI - source index 
</code></pre><p>EDI - used for string operations as destination index</p><pre><code>DI - destinaton index
</code></pre><p>The registers [ EAX, EBX, ECX, EDX ] can be used as subsections as shown in EAX, it contains a 16bit register AX which is split into two 8 bit registers again AH and AL</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>32-bit register <span style=color:#f92672>[</span>EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP<span style=color:#f92672>]</span>
16-bit register <span style=color:#f92672>[</span>AX, BX, CX, or DX<span style=color:#f92672>]</span>
8-bit register <span style=color:#f92672>[</span>AH, BH, CH, DH, AL, BL, CL, or DL<span style=color:#f92672>]</span> 
</code></pre></div><p>An assembly program can be split into three sections</p><ul><li>The data section</li><li>The bss section</li><li>the text section</li></ul><h2 id=the-data-section>The data section<a href=#the-data-section class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The data section is used for declaring initialized data or constant values, file names or buffer size. This data doesn&rsquo;t change at runtime</p><pre tabindex=0><code>section.data ;(syntax for declaration)

</code></pre><h2 id=the-bss-section>The bss section<a href=#the-bss-section class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The bss section is used for declaring variables</p><pre tabindex=0><code>section.bss ;(syntax for declaration)

</code></pre><h2 id=the-text-section>The text section<a href=#the-text-section class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The text section contains the actual code this begins with a declaration global _start
which tells the kernel where the execution of program begins</p><pre tabindex=0><code>section.text
   global _start ;(syntax for declaration)
_start:

</code></pre><h2 id=stack>STACK<a href=#stack class=hanchor arialabel=Anchor>&#8983;</a></h2><p>It is an abstract data structure which consists of information in a Last In First Out system(LIFO). You put arbitrary objects onto the stack and then you take them off again, much like an in/out tray, the top item is always the one that is taken off and you always put on to the top.</p><p>It generally has a static size per program and frequently used to store function parameters. You push the parameters onto the stack when you call a function and the function either address the stack directly or pops off the variables from the stack.</p><p><img src=/images/stack-convention.png alt></p><h2 id=function-prologue-and-epilogue>Function prologue and epilogue<a href=#function-prologue-and-epilogue class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The prolouge is what happens at the beginning of a function. Its responsibility is to set up the stack frame of the called function. The epilogue is the exact opposite: it is what happens last in a function, and its purpose is to restore the stack frame of the called (parent) function.</p><p>In x86, the ebp register is used by the language to keep track of the function&rsquo;s stack frame. The esp register is used by the processor to point to the most recent addition (the top value) on the stack.</p><p>The call instruction does two things: First it pushes the return address onto the stack, then it jumps to the function being called. Immediately after the call, esp points to the return address on the stack.</p><p>Then the prologue is executed:</p><p><code>push ebp ; Save the stack-frame base pointer (of the calling function).</code></p><p><code>mov ebp, esp ; Set the stack-frame base pointer to be the current</code></p><p><code>; location on the stack.</code></p><p><code>sub esp, N ; Grow the stack by N bytes to reserve space for local variables</code></p><p>At this point, we have:</p><pre tabindex=0><code>
ebp + 4:    Return address
ebp + 0:    Calling function's old ebp value
ebp - 4:    (local variables)

</code></pre><p>The epilogue:</p><pre tabindex=0><code>mov esp, ebp    ; Put the stack pointer back where it was when this function is called

pop ebp         ; Restore the calling function's stack frame.

ret             ; Return to the calling function.
</code></pre><h2 id=instructions>Instructions<a href=#instructions class=hanchor arialabel=Anchor>&#8983;</a></h2><p>There are some basic intructions in assembly language such as add, sub, mul, div</p><h2 id=add>ADD<a href=#add class=hanchor arialabel=Anchor>&#8983;</a></h2><p>add instruction is used to add two numbers together. You can use it to add a value directly to memory or to a register</p><p>Eg: <code>mov rax, 0x1 ;; rax equals to 0x1</code></p><pre><code>mov rbx, 0x2 ;; rbx equals to 0x2

add rbx, rax ;; rbx + rax equals to 0x3
</code></pre><h2 id=sub>SUB<a href=#sub class=hanchor arialabel=Anchor>&#8983;</a></h2><p>sub instruction is the opposite of add as you might guessed it now it is used to subtract</p><p>Eg: <code>mov rax, 0x1 ;; rax equals to 0x1</code></p><pre><code> mov rbx, 0x2 ;; rbx equals to 0x2

 sub  rbx, rax ;; rbx -= rax =&gt; rbx = 0x2 - 0x1 = 0x1 
</code></pre><h2 id=mul>MUL<a href=#mul class=hanchor arialabel=Anchor>&#8983;</a></h2><p>mul instruction is used to perform multiplication. The result is is stored in rax implictily</p><p>Eg: <code>mov rax 0x2</code></p><pre><code>mov rbx 0x2

mul rbx  ;; rax = rax * rbx = 0x2 * 0x2 = 0x4
</code></pre><p>we can also multiply <code>rax</code> with itself</p><p><code>mov rax 0x2</code></p><p><code>mul rax ;; equals rax * rax = 0x4</code></p><h2 id=div>DIV<a href=#div class=hanchor arialabel=Anchor>&#8983;</a></h2><p>divides the contents</p><p><code>mov edx, 0 ; clear dividend</code></p><p><code>mov eax, 0x8003 ; dividend</code></p><p><code>mov ecx, 0x100 ; divisor</code></p><p><code>div ecx ; EAX = 0x80, EDX = 0x3</code></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/ropemporium-ret2win-64bit/><span class=button__icon>←</span>
<span class=button__text>Ropemporium ret2win 64bit</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Copyright ©️ 2021</span>
<span><a href=https://twitter.com/h4x5p4c3>h4x5p4c3</a></span></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div></body></html>